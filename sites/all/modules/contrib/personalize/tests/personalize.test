<?php

/**
 * @file
 * Tests for Personalize module.
 */

/**
 * Base testing functionality for all personalize module tests.
 */
class PersonalizeBaseTest extends DrupalWebTestCase {

  protected $adminUser;
  protected $managerUser;

  /**
   * Asserts that a wrapper div for the specified Option Set has been output.
   *
   * @param int $osid
   *   The Option Set ID.
   */
  protected function assertOptionSet($osid) {
    $elements = $this->xpath('//div[contains(@data-personalize, :osid)]', array(':osid' => $osid));
    $this->assertTrue(count($elements), 'Found an element with the specified data attribute');
  }


  /**
   * Asserts that no wrapper div for the specified Option Set has been output.
   *
   * @param int $osid
   *   The Option Set ID.
   */
  protected function assertNoOptionSet($osid) {
    $elements = $this->xpath('//div[contains(@data-personalize, :osid)]', array(':osid' => $osid));
    $this->assertFalse(count($elements), 'Did not find an element with the specified data attribute');
  }

  /**
   * Helper to assert the number of Option Sets of a given type.
   *
   * @param string $type
   *   The Option Set type to assert the count of.
   * @param int $expected_count
   *   The expected count.
   */
  protected function assertOptionSetCountByType($type, $expected_count) {
    $option_sets_by_type = personalize_option_set_load_by_type($type);
    $this->assertEqual($expected_count, count($option_sets_by_type));
  }

  /**
   * Helper to assert the number of Option Sets of a given agent.
   *
   * @param string $agent
   *   The Option Set agent to assert the count of.
   * @param int $expected_count
   *   The expected count.
   */
  protected function assertOptionSetCountByAgent($agent, $expected_count) {
    $option_sets_by_agent = personalize_option_set_load_by_agent($agent);
    $this->assertEqual($expected_count, count($option_sets_by_agent));
  }

  /**
   * Asserts that the expected settings are present for an option set.
   *
   * @param $personalize_settings
   *   The settings to check
   * @param $osid
   *   The id of hte Option Set to check for.
   * @param $decision_name
   *   The decision name expected to be on the option set.
   * @param $decision_point
   *   The decision point expected to be on the option set.
   * @param $agent_name
   *   The agent name expected to be on the option set.
   * @param $num_options
   *   THe number of options that option set should have
   */
  public function assertOptionSetSettings($personalize_settings, $osid, $decision_name, $decision_point, $agent_name, $num_options, $expected_options = array()) {
    $this->assertTrue(isset($personalize_settings['option_sets'][$osid]));
    $this->assertEqual($agent_name, $personalize_settings['option_sets'][$osid]['agent']);
    $this->assertEqual($decision_name, $personalize_settings['option_sets'][$osid]['decision_name']);
    $this->assertEqual($decision_point, $personalize_settings['option_sets'][$osid]['decision_point']);
    $expected_option_names = array();
    if (empty($expected_options)) {
      $expected_options = array();
      for ($j = 1; $j <= $num_options; $j++) {
        // Get the character corresponding to the option
        // index.
        $char = chr($j + 64);
        $expected_options[] = array(
          'option_id' => 'option-' . $char,
          'option_label' => 'Option ' . $char,
        );
        $expected_option_names[] = 'option-' . $char;
      }
    }
    else {
      foreach ($expected_options as $option_info) {
        $expected_option_names[] = $option_info['option_id'];
      }
    }

    $this->assertEqual($expected_options, $personalize_settings['option_sets'][$osid]['options']);
    $this->assertEqual($expected_option_names, $personalize_settings['option_sets'][$osid]['option_names']);
  }

  /**
   * Asserts that the expected settings are present for an MVT.
   *
   * @param $personalize_settings
   *   The settings to check
   * @param $mvt_name
   *   The name of the MVT to check for
   * @param $option_set_counts
   *   An array of option set counts indicating the number of options
   *   expected to be found in each of the MVT's option sets.
   */
  public function assertMVTBlocks($personalize_settings, $mvt_name, $option_set_counts, $block_ids) {
    $num_option_sets = count($option_set_counts);
    // Confirm that the MVT settings have been loaded as expected.
    $this->assertTrue(isset($personalize_settings['mvt']));
    $this->assertTrue(isset($personalize_settings['mvt'][$mvt_name]));
    $this->assertEqual($num_option_sets, count($personalize_settings['mvt'][$mvt_name]['option_sets']));
    // Assert that each Option Set is represented in the MVT settings.
    $delta_num = 1;
    foreach ($option_set_counts as $osid => $count) {
      $osid = 'osid-' . $osid;
      $this->assertTrue(isset($personalize_settings['mvt']['test-mvt']['option_sets'][$osid]));
      $this->assertEqual('test-mvt', $personalize_settings['mvt']['test-mvt']['option_sets'][$osid]['decision_point']);
      $this->assertEqual($osid, $personalize_settings['mvt']['test-mvt']['option_sets'][$osid]['decision_name']);
      $expected_options = $expected_option_names = array();
      for ($j = 1; $j <= $count; $j++) {
        // Get the character corresponding to the option
        // index.
        $char = chr($j + 64);
        $expected_options[] = array(
          'bid' => array_shift($block_ids),
          'option_id' => 'option-' . $char,
          'option_label' => 'Option ' . $char,
        );
        $expected_option_names[] = 'option-' . $char;
        $delta_num++;
      }
      $this->assertEqual($expected_options, $personalize_settings['mvt']['test-mvt']['option_sets'][$osid]['options']);
      $this->assertEqual($expected_option_names, $personalize_settings['mvt']['test-mvt']['option_sets'][$osid]['option_names']);
    }
  }

  /**
   * Helper function to assert that explicit targeting for a particular option
   * set matches the expected rules.
   *
   * @param stdClass $option_set
   *   The option set to test.
   * @param array $expected
   *   An array of expected targeting for each option.
   */
  protected function assertExplicitTargeting($option_set, $expected) {

    $this->assertEqual(count($expected), count($option_set->options));
    foreach ($option_set->options as $option) {
      if (isset($option['fixed_targeting'])) {
        $this->assertEqual($option['fixed_targeting'], $expected[$option['option_id']]['fixed_targeting']);
        $this->assertEqual($option['fixed_targeting_strategy'], $expected[$option['option_id']]['fixed_targeting_strategy']);
        $this->assertEqual($option['fixed_targeting_rules'], $expected[$option['option_id']]['fixed_targeting_rules']);
      }
      else {
        $this->assertFalse(isset($expected[$option['option_id']]['fixed_targeting']));
        $this->assertFalse(isset($expected[$option['option_id']]['fixed_targeting_strategy']));
        $this->assertFalse(isset($expected[$option['option_id']]['fixed_targeting_rules']));
      }
    }
  }

  /**
   * Helper method to move buttons names to one place to simplify
   * it's maintaining
   *
   * Kind of Page Objects Patterns
   *
   * @param $type string
   * @return string
   */
  protected function getButton($type = '') {
    switch ($type) {
      case 'agent':
        return t('Save campaign settings');
      case 'goal':
        return t('Save goals');
      case 'add_goal':
        return t('Add goal');
      case 'option':
        return t('Save variation sets');
      case 'mvt':
        return t('Save test');
      case 'delete':
        return t('Delete');
      case 'config':
        return t('Save configuration');
      case 'add_visitor_action':
        return t('Save');
      default:
        return t($type);
    }
  }

  /**
   * Helper function to create and test queue creation of Personalize Agent
   *
   * @param array $data
   *  array (
   *    'name' => Agent title
   *    'machine_name' => string processed by personalize_generate_machine_name()
   *  )
   * @param bool $cleanQueue Clean or not Drupal queue after 'saveAgent' queue testing
   * @return NULL|PersonalizeAgentInterface
   *
   * @see personalize_generate_machine_name()
   * @see testSaveAgent()
   */
  protected function createTestAgent($data = array()) {
    $data += array(
      'name' => $this->randomName(),
    );

    $data += array('machine_name' => personalize_generate_machine_name($data['name'], 'personalize_agent_machine_name_exists'));

    $edit = array(
      'agent_basic_info[title]' => $data['name'],
      'agent_basic_info[machine_name]' => $data['machine_name'],
      'agent_basic_info[agent_type]' => $data['agent_type'],
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    $agent = personalize_agent_load_agent($data['machine_name'], TRUE);
    $this->assertTrue($agent instanceof PersonalizeAgentBase);
    return $agent;
  }

  /**
   * Helper function to create an option set.
   *
   * @param int $index
   *   The index for this option set within the campaign.
   * @param array $option_set
   *   An associative array of option set data.
   *
   * @return stdClass
   *   The option set created for the campaign.
   */
  protected function createOptionSet($index, $option_set) {
    if (!isset($option_set['label'])) {
      $option_set['label'] = 'Option Set ' . ($index + 1);
    }

    foreach ($option_set['options'] as $i => &$option) {
      if (!isset($option['option_id'])) {
        $option['option_id'] = personalize_generate_option_id($i);
      }
      if (!isset($option['option_label'])) {
        $option['option_label'] = personalize_generate_option_label($i);
      }
    }

    $option_set = (object) $option_set;
    personalize_option_set_save($option_set);
    return $option_set;
  }

  /**
   * Creates a user profile field which can be used for targeting.
   *
   * @return array
   *   An associative array representing the field.
   */
  protected function createUserProfileField($field_name = NULL) {
    $field_name = empty($field_name) ? $this->randomName() : $field_name;
    $field = array(
      'field_name' => 'field_' . drupal_strtolower($field_name),
      'type' => 'text',
      'cardinality' => 1,
    );

    field_create_field($field);
    $fieldInstance = array(
      'field_name' => $field['field_name'],
      'entity_type' => 'user',
      'bundle' => 'user',
      'settings' => array(
        'user_register_form' => FALSE,
      ),
    );

    field_create_instance($fieldInstance);
    return $field;
  }

  /**
   * Creates a user profile field that's just a single on/off checkbox.
   */
  protected function createBooleanProfileField($field_name = NULL, $on_value = 'on', $off_value = 'off') {
    $field_name = empty($field_name) ? $this->randomName() : $field_name;
    // Boolean field.
    $field = array(
      'field_name' => 'field_' . drupal_strtolower($field_name),
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array(
        'allowed_values' => array(0 => $off_value, 1 => $on_value),
      ),
    );
    $field = field_create_field($field);
    // Create an instance of the 'boolean' field.
    $instance = array(
      'field_name' => $field['field_name'],
      'entity_type' => 'user',
      'bundle' => 'user',
      'widget' => array(
        'module' => 'options',
        'type' => 'options_onoff',
      ),
    );
    field_create_instance($instance);
    return $field;
  }

  /**
   * Creates the required number of custom blocks.
   *
   * @param int $num
   *   The number of blocks to create.
   *
   * @return array
   *   An array of block deltas for use in personalized blocks.
   */
  protected function createCustomBlocks($num = 1) {
    $deltas = array();
    module_load_include('inc', 'personalize_blocks', 'personalize_blocks.admin');
    for ($i = 1; $i <= $num; $i++) {
      $title = t('Custom block @num', array('@num' => $i));
      $values = array(
        'title' => $title,
        'info' => $title,
        'body' => array(
          'format' => 'filtered_html',
          'value' => 'Some value',
        )
      );
      $deltas[] = _personalize_blocks_add_custom_block($values);
    }
    return $deltas;
  }

}

/**
 * Tests the personalization functionality on a site.
 */
class PersonalizeTest extends PersonalizeBaseTest {

  public static function getInfo() {
    return array(
      'name' => t('Personalize Tests'),
      'description' => t('Tests basic functionality of Personalize module.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test', 'personalize_blocks'));
  }

  function testPermissions() {
    // @todo test all permissions
  }

  /**
   * Tests personalization behavior under multiple scenarios.
   *
   * The test page accepts various arguments determining the behavior of the page
   * with regard to number of option sets output, number of goals processed and
   * whether these option sets and goals pertain to 1 agent or 2 different agents.
   * The assertions here make sure that in each case the correct js settings for
   * personalization are set on the page and the correct number of option sets
   * have been output.
   *
   * @see personalize_test_personalized_page().
   */
  function testPersonalizePage() {
    // Set initial status of the campaigns.
    personalize_agent_set_status('test-agent', PERSONALIZE_STATUS_RUNNING);
    personalize_agent_set_status('test-agent-2', PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();
    $this->drupalGet('');
    // Confirm that there is no js file loaded for the test agent.
    $this->assertNoRaw('personalize_test.js');
    // Call the test page with no params - results in just one Option Set
    // with two options being output.
    $this->drupalGet('personalize-test/personalized-page');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $expected_agent_map = array(
      'test-agent' => array(
        'type' => 'test_agent',
        'label' => 'My Test Agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array(),
        'cache_decisions' => TRUE,
      )
    );
    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    // Assert that the js for the agent has been loaded.
    $this->assertRaw('personalize_test.js');

    // Assert that the option set has been output.
    $this->assertOptionSet('test-os-1');
    $this->assertOptionSetSettings($personalize_settings, 'test-os-1', 'test-os-1', 'test-os-1', 'test-agent', 2);
    // Call the test page specifying one option set with 3 option, and one
    // goal with the name 'my-goal'.
    $this->drupalGet('personalize-test/personalized-page/3/my-goal');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];

    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    $expected_goals_attained = array(
      'test-agent' => array(
        0 => array(
          'name' => 'my-goal',
          'value' => 1,
        )
      )
    );
    $this->assertEqual($expected_goals_attained, $personalize_settings['goals_attained']);

    // Assert that the option set has been output.
    $this->assertOptionSet('test-os-1', 'test-agent', 'option-A,option-B,option-C');


    // Call the test page specifying 2 Option Sets with 3 and 2 options respectively,
    // and 2 goals to process, 'my-goal' and 'other-goal'.
    $this->drupalGet('personalize-test/personalized-page/3,2/my-goal,other-goal');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];

    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    $expected_goals_attained = array(
      'test-agent' => array(
        array(
          'name' => 'my-goal',
          'value' => 1,
        ),
        array(
          'name' => 'other-goal',
          'value' => 1,
        )
      )
    );
    $this->assertEqual($expected_goals_attained, $personalize_settings['goals_attained']);

    // Assert that the option sets have been output.
    $this->assertOptionSet('test-os-1', 'test-agent', 'option-A,option-B,option-C');


    // Call the test page specifying 3 Option Sets with 3, 4 and 2 options respectively,
    // with 3 goals to process, 'my-goal', 'other-goal' and 'yag', and specifying
    // multiple agents to be used (the test page will use the first test agent for the
    // first option set and goal and the second test agent for all subsequent option sets
    // and goals).
    $this->drupalGet('personalize-test/personalized-page/3,4,2/my-goal,other-goal,yag/1');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $expected_agent_map = array(
      'test-agent' => array(
        'type' => 'test_agent',
        'label' => 'My Test Agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array(),
        'cache_decisions' => TRUE,
      ),
      'test-agent-2' => array(
        'type' => 'test_agent',
        'label' => 'My Second Test Agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array(),
        'cache_decisions' => TRUE,
      )
    );
    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    $expected_goals_attained = array(
      'test-agent' => array(
        array(
          'name' => 'my-goal',
          'value' => 1,
        ),
      ),
      'test-agent-2' => array(
        array(
          'name' => 'other-goal',
          'value' => 1,
        ),
        array(
          'name' => 'yag',
          'value' => 1,
        )
      )
    );
    $this->assertEqual($expected_goals_attained, $personalize_settings['goals_attained']);

    // Assert that the option sets have been output.
    $this->assertOptionSet('test-os-1', 'test-agent', 'option-A,option-B,option-C');
    $this->assertOptionSet('test-os-2', 'test-agent-2', 'option-A,option-B,option-C,option-D');
    $this->assertOptionSet('test-os-3', 'test-agent-2', 'option-A,option-B');


    // We should have an actionListeners property.
    $expected_action_listeners = array(
      'my_test_action' => array(
        array(
          'agent' => 'test-agent',
          'value' => 5
        )
      )
    );
    $this->assertEqual($expected_action_listeners, $personalize_settings['actionListeners']);
  }

  function testPersonalizePageCompletedCampaign() {
    // Set initial status of the campaigns.
    personalize_agent_set_status('test-agent', PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();
    // Call the test page with no params - results in just one Option Set
    // with two options being output.
    $this->drupalGet('personalize-test/personalized-page');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $expected_agent_map = array(
      'test-agent' => array(
        'type' => 'test_agent',
        'label' => 'My Test Agent',
        'active' => PERSONALIZE_STATUS_RUNNING,
        'enabled_contexts' => array(),
        'cache_decisions' => TRUE,
      )
    );
    $this->assertEqual($expected_agent_map, $personalize_settings['agent_map']);
    // Assert that the js for the agent has been loaded.
    $this->assertRaw('personalize_test.js');

    // Assert that the option set has been output.
    $this->assertOptionSet('test-os-1');
    $this->assertOptionSetSettings($personalize_settings, 'test-os-1', 'test-os-1', 'test-os-1', 'test-agent', 2);

    // Now set the campaign's status to completed and confirm that it is rendered in
    // PHP and no js settings are there.
    personalize_agent_set_status('test-agent', PERSONALIZE_STATUS_COMPLETED);
    $this->resetAll();

    $this->drupalGet('personalize-test/personalized-page');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $this->assertFalse(isset($personalize_settings['agent_map']));

    // Assert that the js for the agent has not been loaded.
    $this->assertNoRaw('personalize_test.js');

    // Assert that the option set has not been output.
    $this->assertNoOptionSet('test-os-1');
    $this->assertFalse(isset($personalize_settings['option_sets']));

    // Assert that the content of the first option has been output.
    $this->assertText('OHAI 0' );

    // Now get a personalized page where the option set has the winner set to option B.
    variable_set('personalize_test_os_winner_test-os-1', 'option-B');
    $this->drupalGet('personalize-test/personalized-page');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $this->assertFalse(isset($personalize_settings['agent_map']));

    // Assert that the js for the agent has been loaded.
    $this->assertNoRaw('personalize_test.js');

    // Assert that the option set has not been output.
    $this->assertNoOptionSet('test-os-1');
    $this->assertFalse(isset($personalize_settings['option_sets']));

    // Assert that the content of the first option has been output.
    $this->assertNoText('OHAI 0' );
    $this->assertText('OHAI 1' );
  }

  /**
   * Tests server-side triggering of goals.
   */
  function testServerSideGoal() {
    $this->drupalGet('personalize-test/goal');
    $this->assertText('The my-goal goal with value 2 was received by the test-agent-3 agent');
    // Test that goal that is set during a form submit that then redirects does
    // get sent.
    $this->drupalPost('personalize-test/goal-form', array(), t('Send Goal'));
    $this->assertText('The some-goal goal with value 4 was received by the test-agent-3 agent');
  }

  /**
   * Tests subscribing goals to actions and deleting goals.
   */
  function testGoalSubscriber() {
    // At first there should be no subscribers to the form_submit
    // action.
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertTrue(empty($subscribers));

    // Save a goal with this action and confirm it now has a subscriber.
    personalize_goal_save('test-agent', 'user_login', 3);
    $first_goal_id = db_select('personalize_campaign_goals', 'g')
      ->fields('g', array('id'))
      ->condition('action', 'user_login')
      ->condition('agent', 'test-agent')
      ->execute()
      ->fetchField();

    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertEqual(1, count($subscribers));

    // Save another goal, the action should still have one subscriber.
    personalize_goal_save('test-agent-2', 'user_login', 2);
    $second_goal_id = db_select('personalize_campaign_goals', 'g')
      ->fields('g', array('id'))
      ->condition('action', 'user_login')
      ->condition('agent', 'test-agent-2')
      ->execute()
      ->fetchField();

    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertEqual(1, count($subscribers));

    // Delete the first goal, should still be one subscriber.
    personalize_goal_delete($first_goal_id);
    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertEqual(1, count($subscribers));

    // When we delete the second goal, the action should go back to
    // having no subscribers.
    personalize_goal_delete($second_goal_id);

    drupal_static_reset();
    $subscribers = visitor_actions_get_subscribers('user_login');
    $this->assertTrue(empty($subscribers));
  }

  /**
   * Tests loading and caching of option sets.
   */
  function testOptionSetLoading() {
    // Add some dummy option sets to the database.
    $option_set_values = array(
      array('agent' => 'some-agent', 'plugin' => 'type1', 'num_options' => 3),
      array('agent' => 'other-agent', 'plugin' => 'type1', 'num_options' => 2),
      array('agent' => 'some-agent', 'plugin' => 'type2', 'num_options' => 2),
      array('agent' => 'other-agent', 'plugin' => 'type2', 'num_options' => 4),
      array('agent' => 'some-agent', 'plugin' => 'type3', 'num_options' => 5),
      array('agent' => 'third-agent', 'plugin' => 'type4', 'num_options' => 3),
    );
    foreach ($option_set_values as $i => $values) {
      $option_set = array(
        'plugin' => $values['plugin'],
        'label' => 'Option Set ' . ($i + 1),
        'agent' => $values['agent'],
      );
      $options = array();
      for ($j = 0; $j < $values['num_options']; $j++) {
        $options[$j] = array(
          'option_id' => personalize_generate_option_id($j),
          'option_label' => personalize_generate_option_label($j),
        );
      }
      $option_set['options'] = $options;
      personalize_option_set_save((object)$option_set);
    }

    // First load Option Sets by type and assert that we get the correct number
    // of each type.
    $this->assertOptionSetCountByType('type1', 2);
    $this->assertOptionSetCountByType('type2', 2);
    $this->assertOptionSetCountByType('type3', 1);
    $this->assertOptionSetCountByType('type4', 1);

    // Now load Option Sets by agent name and again check that we get the right
    // number of each.
    $this->assertOptionSetCountByAgent('some-agent', 3);
    $this->assertOptionSetCountByAgent('other-agent', 2);
    $this->assertOptionSetCountByAgent('third-agent', 1);

    // The caches will now have been primed so even if we delete all of the Option
    // Sets from the db, we should be able to load all of them by their IDs or by
    // type or agent from the relevant static cache.
    db_delete('personalize_option_sets')->execute();
    // Load by IDs
    for ($i = 1; $i <= 6; $i++) {
      $os = personalize_option_set_load($i);
      $this->assertNotNull($os);
    }
    // Load by type.
    $this->assertOptionSetCountByType('type1', 2);
    $this->assertOptionSetCountByType('type2', 2);
    $this->assertOptionSetCountByType('type3', 1);
    $this->assertOptionSetCountByType('type4', 1);

    // Load by agent.
    $this->assertOptionSetCountByAgent('some-agent', 3);
    $this->assertOptionSetCountByAgent('other-agent', 2);
    $this->assertOptionSetCountByAgent('third-agent', 1);

    // Now reset the static cache and we should not have any Option Sets.
    drupal_static_reset();
    // Load by IDs and assert we get NULL for each one.
    for ($i = 0; $i < 6; $i++) {
      $os = personalize_option_set_load($i);
      $this->assertFalse($os);
    }
    // Load by type and the count should be 0 for each type.
    $this->assertOptionSetCountByType('type1', 0);
    $this->assertOptionSetCountByType('type2', 0);
    $this->assertOptionSetCountByType('type3', 0);
    $this->assertOptionSetCountByType('type4', 0);

    // Load by agent and the count should be 0 for each agent
    $this->assertOptionSetCountByAgent('some-agent', 0);
    $this->assertOptionSetCountByAgent('other-agent', 0);
    $this->assertOptionSetCountByAgent('third-agent', 0);
  }

  /**
   * Tests loading MVTs on a page.
   */
  function testMVTLoad() {
    $mvt = new stdClass();
    $mvt->label = 'Test Mvt';
    $mvt->agent = 'test-agent';
    $mvt->machine_name = 'test-mvt';
    $mvt->option_sets = array();
    // Create some custom blocks to use as variations.
    $block_ids = $this->createCustomBlocks(8);
    $option_counts = array(2, 3, 3);
    // This array will have osids as keys with the corresponding option count as
    // the value.
    $option_set_count_mappings = array();
    $delta = 0;
    for ($i = 0; $i < 3; $i++) {
      // Add different numbers of options to the option sets.
      $options = array();
      for ($j = 0; $j < $option_counts[$i]; $j++) {
        $options[] = array('bid' => $block_ids[$delta]);
        $delta++;
      }
      $option_set = $this->createOptionSet($i, array('plugin' => 'block', 'agent' => 'test-agent', 'options' => $options, 'data' => array('block_title' => $this->randomName())));
      $mvt->option_sets[$option_set->osid] = $option_set;
      $option_set_count_mappings[$option_set->osid] = $option_counts[$i];
    }
    personalize_mvt_save($mvt);
    // Call the test page specifying the multivariate test to be rendered.
    $this->drupalGet('personalize-test/personalized-page/test-mvt/my-goal/0');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    $this->assertMVTBlocks($personalize_settings, 'test-mvt', $option_set_count_mappings, $block_ids);

    // Now call the test page specifying the MVT test plus a regular option
    // set that is not part of the MVT.
    $this->drupalGet('personalize-test/personalized-page/test-mvt,2/my-goal/0');
    $settings = $this->drupalGetSettings();
    $personalize_settings = $settings['personalize'];
    // The MVT settings should be exactly the same.
    $this->assertMVTBlocks($personalize_settings, 'test-mvt', $option_set_count_mappings, $block_ids);
    $this->assertOptionSetSettings($personalize_settings, 'test-os-2', 'test-os-2', 'test-os-2', 'test-agent', 2);
  }

  /**
   * Create an agent and confirm that the cache_decisions setting is reflected
   * in the js settings.
   */
  function testCacheDecisions() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_agent',
      'cache_decisions' => FALSE,
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $this->createOptionSet(0, array('plugin' => 'block', 'agent' => $machine_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));

    // Now let's place the block in a region and make sure the correct js settings
    // show up when it's rendered on a page.
    $edit = array();
    $edit['blocks[personalize_blocks_1][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();

    $this->drupalGet('');
    $settings = $this->drupalGetSettings();

    // Assert that the decision caching setting is in the js.
    $this->assertEqual(0, $settings['personalize']['agent_map'][$machine_name]['cache_decisions']);

    // Now turn on decision caching for this agent.
    $edit = array('cache_decisions' => TRUE);
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('agent'));

    $this->drupalGet('');
    $settings = $this->drupalGetSettings();

    // Assert that the decision caching setting is in the js.
    $this->assertEqual(1, $settings['personalize']['agent_map'][$machine_name]['cache_decisions']);
  }

  /**
   * Tests the ajax callback executor available for personalized blocks.
   *
   * This test also tests the setting of the executor setting.
   */
  function testAjaxCallbackExecutor() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);

    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Add some personalized blocks to the form.
    $personalized_blocks_form_state = array(
      'values' => array(
        'agent_select' => $machine_name,
        'title' => $this->randomName(),
        'blocks' => array(
          array(
            'option_label' => 'Option A',
            'option_id' => 'option-A',
            'weight' => 0,
            'block' => array(
              'bid' => 'comment_delta_recent',
            ),
            'remove' => 'remove_0',
          ),
          array(
            'option_label' => 'Option B',
            'option_id' => 'option-B',
            'weight' => 1,
            'block' => array(
              'bid' => 'system_delta_powered-by',
            ),
            'remove' => 'remove_1',
          ),
          array(
            'option_label' => 'Option C',
            'option_id' => 'option-C',
            'weight' => 2,
            'block' => array(
              'bid' => 'user_delta_online',
            ),
            'remove' => 'remove_2',
          ),
        ),
      ),
    );
    $option_set = personalize_option_set_save(_personalize_blocks_convert_form_to_personalized_block($personalized_blocks_form_state));
    $osid = $option_set->osid;

    // Go to the campaign edit form and verify rendering options.
    $this->drupalGet("admin/structure/personalize/manage/{$machine_name}/edit");
    $this->assertFieldByName("option_sets[option_set_{$osid}][advanced][executor]", 'show');
    $this->assertFieldByName("option_sets[option_set_{$osid}][advanced][executor]", 'callback');

    // Show should be checked by default.
    $this->assertFieldChecked("edit-option-sets-option-set-{$osid}-advanced-executor-show");

    // Now update to callback.
    $edit = array(
      "option_sets[option_set_{$osid}][advanced][executor]" => 'callback',
      "option_sets[option_set_{$osid}][advanced][label]" => $option_set->label,
    );
    $this->drupalPost(null, $edit, $this->getButton('option'));

    // Now callback should be checked.
    $this->assertFieldChecked("edit-option-sets-option-set-{$osid}-advanced-executor-callback");

    // Place these blocks on a page.
    $edit = array();
    $edit['blocks[personalize_blocks_1][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

    // Verify on page there isn't a template script tag for the option set.
    $show_pattern = '/<div class="personalize-option-set" data-personalize="osid-' . $osid . '">(\s*(<noscript>(.*?)<\/noscript>?)\s*)?\s*<script type="text\/template">/is';

    $this->drupalGet('');
    $this->assertNoPattern($show_pattern);

    // Change the rendering to show.
    $edit = array(
      "option_sets[option_set_{$osid}][advanced][executor]" => 'show',
      "option_sets[option_set_{$osid}][advanced][label]" => $option_set->label,
    );
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('option'));

    // Verify on the page there is a template script tag for the option set.
    $this->drupalGet('');
    $this->assertPattern($show_pattern);

    // Verify the JSON that would be returned for a specific choice.
    $commands = $this->drupalGetAJAX("personalize/option_set/osid-{$osid}/option-A/ajax");
    $selector = "personalize-osid-{$osid}";
    foreach ($commands as $command) {
      if ($command['command'] == 'insert') {
        $this->assertEqual($command['selector'], "#{$selector}");
        $this->assertEqual(strpos($command['data'], '<div id="' . $selector . '">'), 0, 'Response begins by replacing the selector.');
      }
    }
  }

  /**
   * Tests that the visitor context expiration cache is properly set and
   * cleared as needed.
   */
  function testVisitorContextExpirationCache() {
    module_enable(array('personalize_test_extra_agent', 'personalize_test_visitor_context'));
    // Create an agent.
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks', 'administer personalize configuration'));
    $this->drupalLogin($admin_user);

    // Additional agent types aren't available until we reset.
    $this->resetAll();

    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
      'cache_decisions' => FALSE,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    $agent = personalize_agent_load($machine_name);
    $agent->data['visitor_context']['personalize_test_visitor_context'] = array(
      'test_session' => 'test_session',
      'test_local_none' => 'test_local_none',
      'test_nocache' => 'test_nocache',
    );
    personalize_agent_save($agent);

    // Create a block based option set.
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $this->createOptionSet(1, array('plugin' => 'block', 'agent' => $machine_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_RUNNING);

    // Don't remove until this is fixed: https://drupal.org/node/2256243
    $this->resetAll();
    // Load a page and verify cache settings.
    $this->drupalGet('');

    // Verify the cache settings are in the Drupal settings.
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_session'], 'session');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_30']));
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_none'], 'none');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_nocache']));

    // Create a second agent that uses some of the same contexts.
    $second_agent_name = $this->randomName();
    $second_machine_name = personalize_generate_machine_name($second_agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $second_agent_name,
      'agent_basic_info[machine_name]' => $second_machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
      'cache_decisions' => FALSE,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    $second_agent = personalize_agent_load($second_machine_name);
    $second_agent->data['visitor_context']['personalize_test_visitor_context'] = array(
      'test_local_30' => 'test_local_30',
      'test_local_none' => 'test_local_none',
      'test_nocache' => 'test_nocache',
    );
    personalize_agent_save($second_agent);
    personalize_agent_set_status($second_machine_name, PERSONALIZE_STATUS_RUNNING);

    $this->resetAll();
    // Load a page and verify cache settings.
    $this->drupalGet('');

    // Verify the cache settings of the combined agents.
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_session'], 'session');
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_30'], 30);

    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_none'], 'none');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_nocache']));

    // Pause both campaigns and verify that the settings are no longer there.
    personalize_agent_set_status($second_machine_name, PERSONALIZE_STATUS_PAUSED);
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_PAUSED);
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_session']));
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_30']));
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_none']));
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_nocache']));

    // Restart the first agent and verify that the settings come back.
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_RUNNING);
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_session'], 'session');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_30']));
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_none'], 'none');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_nocache']));

    // Remove one of the contexts from those allowed and verify it is removed.
    $edit = array(
      'personalize_visitor_context_disabled[]' => 'personalize_test_visitor_context__test_session',
    );
    $this->drupalPost('admin/config/content/personalize', $edit, $this->getButton('config'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:test_session']));
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_30']));
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_none'], 'none');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_nocache']));

    // Add a personalized block based option set and use the unused context for
    // fixed targeting.
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $os_2 = $this->createOptionSet(2, array('plugin' => 'block', 'agent' => $agent->machine_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));
    $osid2 = $os_2->osid;
    $this->resetAll();
    $edit = array(
      "option_sets[option_set_$osid2][options][option-A][enable_explicit_targeting]" => 1,
      "option_sets[option_set_$osid2][options][option-A][explicit_targeting][mapping][contexts][0][context]" => 'personalize_test_visitor_context__test_local_30',
      "option_sets[option_set_$osid2][options][option-A][explicit_targeting][mapping][contexts][0][value][operator]" => 'starts',
      "option_sets[option_set_$osid2][options][option-A][explicit_targeting][mapping][contexts][0][value][match]" => 'first value',
      "option_sets[option_set_$osid2][options][option-A][explicit_targeting][strategy]" => 'OR',
    );
    $this->drupalPost("admin/structure/personalize/manage/{$agent->machine_name}/edit", $edit, $this->getButton('option'));

    // Start the agent up and verify the various contexts are included.
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_RUNNING);
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:test_session']));
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_30'], '30');
    $this->assertEqual($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_local_none'], 'none');
    $this->assertFalse(isset($settings['personalize']['cacheExpiration']['visitor_context:personalize_test_visitor_context:test_nocache']));
  }
}

/**
 * Tests for important helper functions.
 */
class PersonalizeFundamentalsTest extends PersonalizeBaseTest {

  public static function getInfo() {
    return array(
      'name' => t('Personalize Fundamentals'),
      'description' => t('Tests the important helper functions'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize'));
  }

  /**
   * Tests agent machine name generation.
   */
  function testAgentMachineNameGeneration() {
    $agent_name = 'Some Name$% with Disallow#d  Ch@racters';
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $this->assertEqual('some-name-with-disallow-d-ch-racters', $machine_name);
    // Test with a name greater than the max length.
    $agent_name = 'Some Name$% with Disallow#d  Ch@racters  that exceeds the max allowed  length';
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $this->assertEqual('some-name-with-disallow-d-ch-racters-that-exceeds-the-max-allowe', $machine_name);
    // Test with a different replace character.
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists', '_');
    $this->assertEqual('some_name_with_disallow_d_ch_racters_that_exceeds_the_max_allowe', $machine_name);
  }

  /**
   * Tests the personalize_ensure_unique_option_ids() function.
   */
  public function testUniqueOptionIDs() {
    // Test an array with already unique option IDs.
    $options = array(
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
    );
    $unique_options = personalize_ensure_unique_option_ids($options);
    $this->assertEqual($options, $unique_options);

    // Add a new option with the same id as an existing one.
    $options[] = array('option_id' => 'option-A', 'option_label' => 'Option C');
    $unique_options = personalize_ensure_unique_option_ids($options);
    // The new option should be renamed to option-C.
    $expected = array(
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-C', 'option_label' => 'Option C')
    );
    $this->assertEqual($expected, $unique_options);
    // Add another new option with the same id as an existing one.
    $options[] = array('option_id' => 'option-A', 'option_label' => 'Option D');
    $unique_options = personalize_ensure_unique_option_ids($options);
    // The new option should be renamed to option-C.
    $expected = array(
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-D', 'option_label' => 'Option D'),
    );
    $this->assertEqual($expected, $unique_options);

    // Now create a set of options with multiple repetitions and indexes
    // all over the place.
    $options = array(
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-D', 'option_label' => 'Option D'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-I', 'option_label' => 'Option I'),
    );
    $unique_options = personalize_ensure_unique_option_ids($options);
    // Option labels won't change be IDs should now be unique and in this
    // order.
    $expected = array(
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-E', 'option_label' => 'Option B'),
      array('option_id' => 'option-F', 'option_label' => 'Option C'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-G', 'option_label' => 'Option A'),
      array('option_id' => 'option-D', 'option_label' => 'Option D'),
      array('option_id' => 'option-H', 'option_label' => 'Option B'),
      array('option_id' => 'option-J', 'option_label' => 'Option A'),
      array('option_id' => 'option-I', 'option_label' => 'Option I'),
    );
    $this->assertEqual($expected, $unique_options);

    // Now add some IDs with invalid characters into the mix.
    array_unshift($options, array('option_id' => 'option C', 'option_label' => 'Option C'));
    $options[7] = $options[8] = array('option_id' => 'OHAI LOL', 'option_label' => 'Option D');
    $unique_options = personalize_ensure_unique_option_ids($options);

    $expected = array(
      array('option_id' => 'option-C', 'option_label' => 'Option C'),
      array('option_id' => 'option-D', 'option_label' => 'Option C'),
      array('option_id' => 'option-B', 'option_label' => 'Option B'),
      array('option_id' => 'option-E', 'option_label' => 'Option B'),
      array('option_id' => 'option-F', 'option_label' => 'Option C'),
      array('option_id' => 'option-A', 'option_label' => 'Option A'),
      array('option_id' => 'option-G', 'option_label' => 'Option A'),
      array('option_id' => 'OHAI-LOL', 'option_label' => 'Option D'),
      array('option_id' => 'option-J', 'option_label' => 'Option D'),
      array('option_id' => 'option-K', 'option_label' => 'Option A'),
      array('option_id' => 'option-I', 'option_label' => 'Option I'),
    );
    $this->assertEqual($expected, $unique_options);

    // Generate option IDs from labels.
    $options = array(
      array('option_label' => 'Some Option ID'),
      // Add an option with the same label as the previous one.
      array('option_label' => 'Some Option ID'),
    );
    $unique_options = personalize_ensure_unique_option_ids($options);
    $expected = array(
      array('option_id' => 'some-option-id', 'option_label' => 'Some Option ID'),
      array('option_id' => 'option-B', 'option_label' => 'Some Option ID'),
    );
    $this->assertEqual($expected, $unique_options);
  }

}

class PersonalizeOptionSetTest extends PersonalizeBaseTest {

  public static function getInfo() {
    return array(
      'name' => t('Personalize Option Set Tests'),
      'description' => t('Tests for Option Set behavior.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test', 'personalize_blocks'));
  }

  /**
   * Create a winning content variation and test that it is returned as the
   * winner.
   */
  function testWinningOption() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    $personalized_blocks_form_state = array(
      'values' => array(
        'agent_select' => $machine_name,
        'title' => $this->randomName(),
        'blocks' => array(
          array(
            'option_label' => 'Option A',
            'option_id' => 'option-A',
            'weight' => 0,
            'block' => array(
              'bid' => 'comment_delta_recent',
            ),
            'remove' => 'remove_0',
          ),
          array(
            'option_label' => 'Option B',
            'option_id' => 'option-B',
            'weight' => 1,
            'block' => array(
              'bid' => 'system_delta_powered-by',
            ),
            'remove' => 'remove_1',
          ),
          array(
            'option_label' => 'Option C',
            'option_id' => 'option-C',
            'weight' => 2,
            'block' => array(
              'bid' => 'user_delta_online',
            ),
            'remove' => 'remove_2',
          ),
        ),
      ),
    );

    $option_set = personalize_option_set_save(_personalize_blocks_convert_form_to_personalized_block($personalized_blocks_form_state));
    $osid = $option_set->osid;

    // We aren't able to check the set as winner link as it is a button rather
    // than a submit input.
    // We can check that the winning option is properly displayed.
    $this->drupalGet("admin/structure/personalize/manage/$machine_name/edit");
    $this->assertNoRaw('<button id="edit-option-sets-option-set-' . $osid . '-options-option-A-basic-winner" class="personalize-add-link" title="Click here to set as winning variation.">Set as Fallback/Winner</button>');
    $this->assertRaw('<button id="edit-option-sets-option-set-' . $osid . '-options-option-B-basic-winner" class="personalize-add-link" title="Click here to set as winning variation.">Set as Fallback/Winner</button>');
    $this->assertRaw('<button id="edit-option-sets-option-set-' . $osid . '-options-option-C-basic-winner" class="personalize-add-link" title="Click here to set as winning variation.">Set as Fallback/Winner</button>');

    $option_set = personalize_option_set_load($osid);
    $option_set->winner = 'option-C';
    personalize_option_set_save($option_set);
    $this->drupalGet("admin/structure/personalize/manage/$machine_name/edit");
    $this->assertRaw('<button id="edit-option-sets-option-set-' . $osid . '-options-option-A-basic-winner" class="personalize-add-link" title="Click here to set as winning variation.">Set as Fallback/Winner</button>');
    $this->assertRaw('<button id="edit-option-sets-option-set-' . $osid . '-options-option-B-basic-winner" class="personalize-add-link" title="Click here to set as winning variation.">Set as Fallback/Winner</button>');
    $this->assertNoRaw('<button id="edit-option-sets-option-set-' . $osid . '-options-option-C-basic-winner" class="personalize-add-link" title="Click here to set as winning variation.">Set as Fallback/Winner</button>');

    // Now let's place the block in a region and make sure the correct js settings
    // show up when it's rendered on a page.
    $edit = array();
    $edit['blocks[personalize_blocks_' . $osid . '][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $option_set_settings = $settings['personalize']['option_sets'];
    // Assert that index 2 is provided as the winner in the settings.
    $this->assertEqual(2, $option_set_settings['osid-' . $osid]['winner']);

  }

  /**
   * Tests creation of decision names and administration of option sets within
   * decisions.
   */
  public function testOptionSetDecisionName() {
    $admin_user = $this->drupalCreateUser(array('manage personalized content', 'access administration pages', 'administer blocks'));
    $this->drupalLogin($admin_user);
    $agent = $this->createTestAgent(array('agent_type' => 'test_agent'));
    $agent_name = $agent->getMachineName();
    // Create two block-based option sets.
    $option_sets = array();
    $block_ids = array('comment_delta_recent', 'system_delta_powered-by', 'user_delta_online', 'user_delta_new');
    for ($i = 0; $i < 2; $i++) {
      // Each option set will have 2 options.
      $options = array(
        array('bid' => array_shift($block_ids)),
        array('bid' => array_shift($block_ids)),
      );
      $option_sets[] = $this->createOptionSet($i, array('plugin' => 'block', 'agent' => $agent_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));
    }
    // We're going to make the second option set have the same decision name as the
    // first, which will tie them together conceptually as one decision.
    $decision_name = personalize_get_decision_name_for_option_set($option_sets[0]);
    $edit = array(
      "option_sets[option_set_{$option_sets[1]->osid}][advanced][decision_name]" => $decision_name
    );
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", $edit, $this->getButton('option'));
    $second_os = personalize_option_set_load($option_sets[1]->osid, TRUE);
    $this->assertEqual(PERSONALIZE_OPTION_SET_PREFIX . $option_sets[0]->osid, $second_os->decision_name);

    // Now let's place the blocks in a region and make sure the correct js settings
    // show up when they're rendered.
    $edit = array();
    $edit['blocks[personalize_blocks_' . $option_sets[0]->osid . '][region]'] = 'sidebar_first';
    $edit['blocks[personalize_blocks_' . $option_sets[1]->osid . '][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $option_set_settings = $settings['personalize']['option_sets'];
    // Assert that both blocks have the same decision name.
    $this->assertEqual($option_set_settings['osid-' . $option_sets[0]->osid]['decision_name'], $option_set_settings['osid-' . $option_sets[1]->osid]['decision_name']);

    // Change both decision names to something else. The string should be converted
    // to a machine name.
    $new_name = 'Some non-machine-readable %name';
    $edit = array(
      "option_sets[option_set_{$option_sets[0]->osid}][advanced][decision_name]" => $new_name,
      "option_sets[option_set_{$option_sets[1]->osid}][advanced][decision_name]" => $new_name
    );
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", $edit, $this->getButton('option'));
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $option_set_settings = $settings['personalize']['option_sets'];
    // Assert that the name was sanitized.
    $this->assertEqual('some-non-machine-readable-name', $option_set_settings['osid-' . $option_sets[0]->osid]['decision_name']);
    // Assert that both blocks have the same decision name.
    $this->assertEqual($option_set_settings['osid-' . $option_sets[0]->osid]['decision_name'], $option_set_settings['osid-' . $option_sets[1]->osid]['decision_name']);
    $set_status = personalize_agent_set_status($agent_name, PERSONALIZE_STATUS_RUNNING);
    // Confirm that there was no problem settings this agent's status to Running.
    $this->assertTrue($set_status);

    // Now change one of the option sets so that the two have different numbers of options.
    $os = personalize_option_set_load($option_sets[1]->osid, TRUE);
    $os->options[] = array(
      'option_id' => 'option-C',
      'option_label' => 'Option C',
      'bid' => 'system_delta_powered-by'
    );
    personalize_option_set_save($os);

    $status = personalize_agent_get_status($agent_name);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, $status);

    // Go to the campaign page and try to set the status to running. We should get an
    // error about the number of options.
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", array(), t('Resume'));
    $this->assertText("The Option Set {$second_os->label} has 3 options but uses the decision some-non-machine-readable-name which requires 2 options");
    // Confirm that the agent is still paused.
    $status = personalize_agent_get_status($agent_name);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, $status);

    // Now add a third option to the other option set but give it a different
    // option ID.
    $os = personalize_option_set_load($option_sets[0]->osid, TRUE);
    $os->options[] = array(
      'option_id' => 'my-new-option',
      'option_label' => 'Option C',
      'bid' => 'user_delta_online'
    );
    personalize_option_set_save($os);

    // Go to the campaign page and try to set the status to running. We should get an
    // error about the option IDs not being the same.
    $this->drupalPost("admin/structure/personalize/manage/{$agent_name}/edit", array(), t('Resume'));
    $this->assertText("The Option Set {$second_os->label} uses the decision some-non-machine-readable-name but has different option IDs. Option IDs cannot be changed so you will need to delete the options and recreate them.");
    // Confirm that the agent is still paused.
    $status = personalize_agent_get_status($agent_name);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, $status);
  }

  /**
   * Tests the option set preview functionality.
   */
  function testOptionSetPreview() {
    // Create a new test campaign with an option set in it.
    $admin_user = $this->drupalCreateUser(array('manage personalized content', 'access administration pages', 'administer blocks'));
    $this->drupalLogin($admin_user);
    $agent = $this->createTestAgent(array('agent_type' => 'test_agent'));
    $agent_name = $agent->getMachineName();

    // Create block-based option set. Each option set will have 2 options.
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $option_set = $this->createOptionSet(0, array('plugin' => 'block', 'agent' => $agent_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));

    // First verify that no preview links appear when the preview link option
    // is empty.
    $this->drupalGet("admin/structure/personalize/manage/{$agent_name}/edit");
    $this->assertNoLink(t('Preview'));

    // Try adding a link to an external page.
    $edit = array(
      'option_sets[option_set_1][advanced][preview_link]' => 'http://google.com',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('option'));
    $this->assertText(t('The preview link for "Option Set 1" must be a valid internal Drupal path.'));

    // Try adding a link to a page that does not exist.
    $edit = array(
      'option_sets[option_set_1][advanced][preview_link]' => 'node/12345',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('option'));
    $this->assertText(t('The preview link for "Option Set 1" must be a valid internal Drupal path.'));

    // Add a good preview link and verify that preview links are added.
    $edit = array(
      'option_sets[option_set_1][advanced][preview_link]' => '<front>',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('option'));
    $this->assertNoText(t('The preview link for "Option Set 1" must be a valid internal Drupal path.'));

    // In the preview link page, test that the option is pre-selected in the
    // settings passed to JavaScript.
    $this->clickLink(t('Preview'), 1);
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['personalize']['preselected']['osid-' . $option_set->osid], 'option-B');
  }

  /**
   * Tests automatic targeting based on campaign-wide context selections.
   */
  function testAutoTargeting() {
    // Enable a test module that provides autotargeting with limited values and
    // an agent that provides autotargeting without limited values.
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();

    // Create user profile fields that we can use for targeting.
    $this->createUserProfileField('test_user_field_1');
    $this->createUserProfileField('test_user_field_2');

    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    // Create a new agent.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    // Check for auto-targeting.
    $this->assertFieldByName('visitor_context[]');

    // Create a block based option set.
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $option_set = $this->createOptionSet(1, array('plugin' => 'block', 'agent' => $machine_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));
    $osid = $option_set->osid;

    // Confirm that we can add a explicit targeting option without setting any auto targeting options.
    $edit = array(
      "option_sets[option_set_$osid][options][option-A][enable_explicit_targeting]" => 1,
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][mapping][contexts][0][context]" => 'user_profile_context__test_user_field_1',
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][mapping][contexts][0][value][operator]" => 'starts',
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][mapping][contexts][0][value][match]" => 'first value',
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][strategy]" => 'OR',
    );
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", $edit, $this->getButton('option'));
    $this->resetAll();
    $option_set = personalize_option_set_load($osid);
    $expected_targeting = array(
      'option-A' => array(
        'fixed_targeting' => array('test_user_field_1--ss-first-value'),
        'fixed_targeting_rules' => array(
          'test_user_field_1--ss-first-value' => array(
            'context' => 'test_user_field_1',
            'match' => 'first value',
            'operator' => 'starts',
            'plugin' => 'user_profile_context',
          ),
        ),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-B' => array(
        'fixed_targeting' => array(),
        'fixed_targeting_rules' => array(),
        'fixed_targeting_strategy' => 'OR',
      ),
    );
    $this->assertExplicitTargeting($option_set, $expected_targeting);

    // Now set some auto targeting as well.
    $edit = array('visitor_context[]' => array('user_profile_context__test_user_field_1' => 'user_profile_context__test_user_field_1'));
    $this->drupalPost('admin/structure/personalize/manage/' . $machine_name . '/edit', $edit, $this->getButton('agent'));

    // Confirm that we have the expected visitor contexts.
    $edit = array();
    $edit["blocks[personalize_blocks_$osid][region]"] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($expected_targeting['option-A']['fixed_targeting'], $settings['personalize']['option_sets']['osid-' . $osid]['options'][0]['fixed_targeting']);
    $this->assertEqual($expected_targeting['option-A']['fixed_targeting_rules'], $settings['personalize']['option_sets']['osid-' . $osid]['options'][0]['fixed_targeting_rules']);
    $this->assertEqual($expected_targeting['option-A']['fixed_targeting_strategy'], $settings['personalize']['option_sets']['osid-' . $osid]['options'][0]['fixed_targeting_strategy']);
  }

  /**
   * Tests automatic targeting based on campaign-wide context selections with
   * fixed targeting values limited to selected contexts.
   */
  function testAutoTargetingLimitedValues() {
    // Enable a test module that provides autotargeting with limited values and
    // an agent that provides autotargeting without limited values.
    module_enable(array('personalize_test_autopersonalize_agent'));
    $this->resetAll();

    // Create user profile fields that we can use for targeting.
    $this->createUserProfileField('test_user_field_1');
    $this->createUserProfileField('test_user_field_2');

    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    // Create a new agent.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_autopersonalize_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    // Check for auto-targeting.
    $this->assertFieldByName('visitor_context[]');

    // Create a block based option set.
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $option_set = $this->createOptionSet(1, array('plugin' => 'block', 'agent' => $machine_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));
    $osid = $option_set->osid;

    // Confirm that we have visitor context options but cannot set fixed targeting.
    $this->drupalGet("admin/structure/personalize/manage/$machine_name/edit");
    $this->assertNoField("option_sets[option_set_$osid][options][option-A][enable_explicit_targeting]");
    $this->assertNoField("option_sets[option_set_$osid][options][option-B][enable_explicit_targeting]");

    // Add some context to the campaign.
    $edit = array('visitor_context[]' => array('user_profile_context__test_user_field_1' => 'user_profile_context__test_user_field_1'));
    $this->drupalPost('admin/structure/personalize/manage/' . $machine_name . '/edit', $edit, $this->getButton('agent'));

    // Confirm that we can add a explicit targeting option now.
    $edit = array(
      "option_sets[option_set_$osid][options][option-A][enable_explicit_targeting]" => 1,
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][mapping][contexts][0][context]" => 'user_profile_context__test_user_field_1',
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][mapping][contexts][0][value][operator]" => 'starts',
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][mapping][contexts][0][value][match]" => 'first value',
      "option_sets[option_set_$osid][options][option-A][explicit_targeting][strategy]" => 'OR',
    );
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", $edit, $this->getButton('option'));
    $this->resetAll();
    $option_set = personalize_option_set_load($osid);
    $expected_targeting = array(
      'option-A' => array(
        'fixed_targeting' => array('test_user_field_1--ss-first-value'),
        'fixed_targeting_rules' => array(
          'test_user_field_1--ss-first-value' => array(
            'context' => 'test_user_field_1',
            'match' => 'first value',
            'operator' => 'starts',
            'plugin' => 'user_profile_context',
          ),
        ),
        'fixed_targeting_strategy' => 'OR'
      ),
      'option-B' => array(
        'fixed_targeting' => array(),
        'fixed_targeting_rules' => array(),
        'fixed_targeting_strategy' => 'OR',
      ),
    );
    $this->assertExplicitTargeting($option_set, $expected_targeting);

    // Confirm that we have the expected visitor contexts.
    $edit = array();
    $edit["blocks[personalize_blocks_$osid][region]"] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($expected_targeting['option-A']['fixed_targeting'], $settings['personalize']['option_sets']['osid-' . $osid]['options'][0]['fixed_targeting']);
    $this->assertEqual($expected_targeting['option-A']['fixed_targeting_rules'], $settings['personalize']['option_sets']['osid-' . $osid]['options'][0]['fixed_targeting_rules']);
    $this->assertEqual($expected_targeting['option-A']['fixed_targeting_strategy'], $settings['personalize']['option_sets']['osid-' . $osid]['options'][0]['fixed_targeting_strategy']);
  }

  /**
   * Tests fixed targeting using a boolean context.
   */
  function testFixedTargetingWithBooleanContext() {
    // Enable a test module that provides fixed targeting.
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();

    // Create user profile fields that we can use for targeting.
    $this->createBooleanProfileField('boolean_user_field_1');

    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    // Create a new agent.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Create block-based option set.

    // Each option set will have 2 options.
    $options = array(
      array('bid' => 'comment_delta_recent'),
      array('bid' => 'system_delta_powered-by'),
    );
    $option_set = $this->createOptionSet(0, array('plugin' => 'block', 'agent' => $agent_name, 'options' => $options, 'data' => array('block_title' => $this->randomName())));

    $agent_data = personalize_agent_load($machine_name);
    module_load_include('inc', 'personalize', 'personalize.admin');
    // Ensure that we get the expected targeting values available for use by our
    // agent for fixed targeting.
    $targeting_values = personalize_get_fixed_targeting_values_for_agent($agent_data);
    $expected_targeting_values = array(
      'boolean_user_field_1' => array(
        'friendly name' => 'field_boolean_user_field_1',
        'value type' => 'boolean',
        'on_label' => 'On',
        'off_label' => 'Off',
        'visitor_context' => 'user_profile_context',
      )
    );
    $this->assertEqual($expected_targeting_values, $targeting_values);
    // Now mock a call to the function to output the form elements, to make sure the
    // boolean value is handled correctly.
    $option = $option_set->options[0];
    // This simulates having selected our user profile field from teh dropdown list.
    $form_state = array(
      'values' => array(
        'option_sets' => array(
          'option_set_1' => array(
            'options' => array(
              $option['option_id'] => array(
                'explicit_targeting' => array(
                  'mapping' => array(
                    'contexts' => array(
                      array(
                        'context' => 'user_profile_context__boolean_user_field_1',
                        'value' => array(
                          'operator' => '',
                          'match' => ''
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );

    $form_elements = personalize_targeting_support_form_elements($option_set, $option, $targeting_values, PersonalizeExplicitTargetingInterface::EXPLICIT_TARGETING_MULTIPLE_BOTH, array(), array('option_sets', 'option_set_1', 'options', $option_set->options[0]['option_id']), $form_state);
    $this->assertEqual('user_profile_context__boolean_user_field_1', $form_elements['mapping']['contexts'][0]['context']['#default_value']);
    $operator_element = $form_elements['mapping']['contexts'][0]['value']['operator'];
    // Assert there is no 'operator' dropdown, just a value element.
    $this->assertEqual('value', $operator_element['#type']);
    $this->assertEqual('equals', $operator_element['#value']);

    $match_element = $form_elements['mapping']['contexts'][0]['value']['match'];
    // Assert the correct options in the match dropdown.
    $this->assertEqual(array(
      0 => 'Off',
      1 => 'On',
    ), $match_element['#options']);
  }
}

class PersonalizeAgentAdminTest extends PersonalizeBaseTest {
  public static function getInfo() {
    return array(
      'name' => t('Personalize Agent Admin Tests'),
      'description' => t('Tests for Agent administration.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test'));
  }

  /**
   * Tests creating a new agent.
   */
  function testAgentCreate() {
    module_disable(array('personalize_test'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);

    // Make sure you can't create a campaign without any agents.
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertText(t('You don\'t have any agent types enabled.'));
    $this->assertNoFieldByName('op', $this->getButton('agent'));

    // Enable a test agent and verify that a campaign edit form is presented.
    module_enable(array('personalize_test'));
    $this->resetAll();
    $agent = personalize_agent_load_agent('test-agent');

    $this->assertTrue($agent instanceof PersonalizeAgentBase);
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertNoText(t('You don\'t have any agent types enabled.'));
    $this->assertFieldByName('op', $this->getButton('agent'));
  }

  /**
   * Tests display of agent type selection when creating a campaign.
   */
  function testMultipleAgentTypes() {
    // Enable our other test module that provides an extra agent type.
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => 1,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    $agent = personalize_agent_load_agent($machine_name);
    $this->assertTrue($agent instanceof PersonalizeTestExtraAgent);

    // Now load the edit form and make sure there is no agent_type element
    // in the form.
    $this->drupalGet("admin/structure/personalize/manage/{$machine_name}/edit");
    $this->assertFieldByName('agent_basic_info[title]');
    $this->assertNoFieldByName('agent_basic_info[agent_type]');
  }

  /**
   * Tests the embedded campaign creation form.
   */
  function testEmbeddedAgentCreationFrom() {
    // First access the form as a logged in user that has access to admin
    // pages but does not have the 'manage personalized content' permission.
    $admin_user = $this->drupalCreateUser(array('access administration pages'));
    $this->drupalLogin($admin_user);
    $this->drupalGet('admin/personalize_test/form');
    $this->assertNoFieldByName('agent_select');
    $this->drupalLogout();
    // Now access the page with the 'manage personalized content' permission.
    $personalization_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($personalization_user);
    $this->drupalGet('admin/personalize_test/form');
    $this->assertFieldByName('agent_select');
    // We should now be able to select an agent from the dropdown and submit
    // the form
    $edit = array(
      'agent_select' => 'test-agent-2',
      'some_other_field' => 'ohai',
    );
    $this->drupalPost('admin/personalize_test/form', $edit, $this->getButton('Submit'));
    $this->assertText('ohai test-agent-2');

    // Now choose to add a new agent instead of selecting an existing one.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_select' => PERSONALIZE_NEW_AGENT_FORM_VALUE,
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => FALSE,
    );
    $this->drupalPost('admin/personalize_test/form', $edit, $this->getButton('Submit'));
    $this->assertText('Agent saved');
    $this->resetAll();
    if ($agent = personalize_agent_load_agent($machine_name)) {
      $this->assertTrue($agent instanceof PersonalizeTestAgent);
      $this->assertFalse($agent->useClientSideGoalDelivery());
    }
    else {
      $this->fail('Agent was not saved');
    }
  }

  /**
   * Tests editing campaign basic information.
   */
  function testAgentEdit() {
    $agent = personalize_agent_load_agent('test-agent');
    $this->assertTrue($agent instanceof PersonalizeAgentBase);
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertResponse(403);
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => 1,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    // Assert that we were redirected to the edit page for this agent.
    $this->assertFieldByName('agent_basic_info[title]');
    // Post the edit form and confirm we are redirected to the listing
    // page afterwards.
    unset($edit['agent_basic_info[machine_name]']);
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('agent'));
    $this->assertNoFieldByName('agent_basic_info[title]');
    $agent = personalize_agent_load_agent($machine_name);
    $this->assertTrue($agent instanceof PersonalizeTestAgent);

    // Verify that the agent does not have an end date specified.
    $end_variable = _personalize_agent_get_stoptime_variable($machine_name);
    $end_date = variable_get($end_variable, 0);
    $this->assertEqual($end_variable, 0);

    // Set the end date via the form.
    $end_date = strtotime('+1 month midnight');
    $edit = array(
      'campaign_end' => 'specified',
      'campaign_end_date[month]' => intval(date('m', $end_date)),
      'campaign_end_date[day]' => date('d', $end_date),
      'campaign_end_date[year]' => date('Y', $end_date),
    );
    $this->drupalPost(NULL, $edit, $this->getButton('agent'));
    $this->assertEqual($end_date, variable_get($end_variable, 0));

    // Reset the end date.
    $edit = array(
      'campaign_end' => 'none',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('agent'));
    $this->assertEqual(0, variable_get($end_variable, 10));
  }

  /**
   * Tests when campaigns are allowed to be deleted.
   */
  function testAgentDelete() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    $agent = $this->createTestAgent(array('agent_type' => 'test_agent'));
    $machine_name = $agent->getMachineName();
    $delete_path = "admin/structure/personalize/manage/$machine_name/delete";
    $this->drupalGet('admin/structure/personalize');
    // It should be possible to delete this agent.
    $this->assertLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(200);

    // Now add an option set.
    $option_set = array(
      'plugin' => 'block',
      'label' => $this->randomName(),
      'agent' => $machine_name,
    );
    $options = array();
    for ($j = 0; $j < 2; $j++) {
      $options[$j] = array(
        'option_label' => personalize_generate_option_label($j),
      );
    }
    $option_set['options'] = $options;
    $option_set = (object) $option_set;
    personalize_option_set_save($option_set);
    $machine_name = $agent->getMachineName();
    $this->drupalGet('admin/structure/personalize');
    // It should no longer be possible to delete this option set.
    $this->assertNoLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(403);

    // Now delete the option set.
    personalize_option_set_delete(1);

    // Set the status of the agent to running.
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_RUNNING);

    $this->drupalGet('admin/structure/personalize');
    // It still should not be possible to delete this option set.
    $this->assertNoLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(403);

    // Set the status of the agent to paused.
    personalize_agent_set_status($machine_name, PERSONALIZE_STATUS_PAUSED);
    $this->drupalGet('admin/structure/personalize');
    // It should now be possible to delete this agent.
    $this->assertLinkByHref($delete_path);
    $this->drupalGet($delete_path);
    $this->assertResponse(200);
    $this->drupalPost(NULL, array(), t('Delete'));
    $this->resetAll();

    $agent_data = personalize_agent_load($machine_name);
    $this->assertNull($agent_data);
  }

  /**
   * Tests changing campaign status.
   */
  function testAgentStatus() {
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create two agents of different types.
    $first_agent_name = $this->randomName();
    $first_agent_machine_name = personalize_generate_machine_name($first_agent_name, 'personalize_agent_machine_name_exists');
    $second_agent_name = $this->randomName();
    $second_agent_machine_name = personalize_generate_machine_name($second_agent_name, 'personalize_agent_machine_name_exists');
    $agents = array(
      array(
        'label' => $first_agent_name,
        'machine_name' => $first_agent_machine_name,
        'agent_type' => 'test_agent',
      ),
      array(
        'label' => $second_agent_name,
        'machine_name' => $second_agent_machine_name,
        'agent_type' => 'test_invalid_agent',
      ),
    );
    foreach ($agents as $agent) {
      $edit = array(
        'agent_basic_info[title]' => $agent['label'],
        'agent_basic_info[machine_name]' => $agent['machine_name'],
        'agent_basic_info[agent_type]' => $agent['agent_type'],
      );
      $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    }
    $time_before = time();
    // The status of each agent should now be "not started"
    $this->assertEqual(PERSONALIZE_STATUS_NOT_STARTED, personalize_agent_get_status($first_agent_machine_name));
    $this->assertEqual(PERSONALIZE_STATUS_NOT_STARTED, personalize_agent_get_status($second_agent_machine_name));
    // Click the "start" button for the first agent.
    $html_id_first_agent = "personalize-toggle-status-{$first_agent_machine_name}-form";
    $this->drupalPost('admin/structure/personalize', array(), t('Start'), array(), array(), $html_id_first_agent);
    // No error should have been set.
    $this->assertNoText('There is a problem with this campaign and it cannot be run at this time');
    // The agent's status should now be "running".
    $this->assertEqual(PERSONALIZE_STATUS_RUNNING, personalize_agent_get_status($first_agent_machine_name));
    // Check the "started" time of the agent, which should now have been set.
    $time_after = time();
    $agent = personalize_agent_load($first_agent_machine_name);
    $this->assertTrue($time_before <= $agent->started && $agent->started <= $time_after);
    // Add an option set to this agent and confirm the agent is then set to paused.
    $option_set = array(
      'plugin' => 'some_type',
      'label' => 'Option Set 1',
      'agent' => $first_agent_machine_name,
    );
    $options = array();
    for ($j = 0; $j < 3; $j++) {
      $options[$j] = array(
        'option_id' => personalize_generate_option_id($j),
        'option_label' => personalize_generate_option_label($j),
      );
    }
    $option_set['options'] = $options;
    personalize_option_set_save((object) $option_set);
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, personalize_agent_get_status($first_agent_machine_name));

    // Now click the start button of the second agent.
    $html_id_second_agent = "personalize-toggle-status-{$second_agent_machine_name}-form";
    $this->drupalPost('admin/structure/personalize', array(), t('Start'), array(), array(), $html_id_second_agent);
    // Its verify() method will have returned false so a message should have been set.
    $this->assertText('There is a problem with this campaign and it cannot be run at this time');
    // The agent's status should still be "not started"
    $this->assertEqual(PERSONALIZE_STATUS_NOT_STARTED, personalize_agent_get_status($second_agent_machine_name));

    // Test setting an agent's status to completed.
    $time_before = time();
    personalize_agent_set_status($first_agent_machine_name, PERSONALIZE_STATUS_COMPLETED);
    $this->resetAll();
    // Check the end time of the agent, which should now have been set.
    $time_after = time();
    $end_time = variable_get(_personalize_agent_get_stoptime_variable($first_agent_machine_name), 0);
    $this->assertTrue($time_before <= $end_time && $end_time <= $time_after);

    // Now test the ajax callback.
    // Expected case to update to next status.
    $expected = array(
      'success' => TRUE,
      'nextStatus' => array(
        'status' => PERSONALIZE_STATUS_PAUSED,
        'text' => t('Pause'),
      ),
      'currentStatus' => PERSONALIZE_STATUS_RUNNING,
    );
    $result = $this->drupalGetAjax('admin/structure/personalize/manage/' . $first_agent_machine_name . '/ajax_status/' . PERSONALIZE_STATUS_RUNNING);
    $this->assertEqual($expected, $result);

    // Try an update that doesn't change the status.
    $result = $this->drupalGetAjax('admin/structure/personalize/manage/' . $first_agent_machine_name . '/ajax_status/' . PERSONALIZE_STATUS_RUNNING);
    $this->assertEqual($expected, $result);

    // Try to update an agent that cannot be verified.
    $expected = array(
      'success' => FALSE,
    );
    $result = $this->drupalGetAjax('admin/structure/personalize/manage/' . $second_agent_machine_name . '/ajax_status/' . PERSONALIZE_STATUS_RUNNING);
    $this->assertEqual($expected, $result);

    // Try to call the path without the proper permissions.
    $this->drupalLogout();
    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent_machine_name . '/ajax_status/' . PERSONALIZE_STATUS_RUNNING);
    $this->assertText(t('Access denied'));
  }

  /**
   * Tests the function that pauses agents that are due to be paused.
   */
  function testPauseAgents() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create some test agents.
    $agent_data = array(
      array(
        'name' => 'agent-1',
        'machine_name' => personalize_generate_machine_name('agent-1', 'personalize_agent_machine_name_exists'),
        'agent_type' => 'test_agent'
      ),
      array(
        'name' => 'agent-2',
        'machine_name' => personalize_generate_machine_name('agent-2', 'personalize_agent_machine_name_exists'),
        'agent_type' => 'test_agent'
      ),
      array(
        'name' => 'agent-3',
        'machine_name' => personalize_generate_machine_name('agent-3', 'personalize_agent_machine_name_exists'),
        'agent_type' => 'test_agent'
      ),
    );
    foreach ($agent_data as $data) {
      $this->createTestAgent($data);
      personalize_agent_set_status($data['machine_name'], PERSONALIZE_STATUS_RUNNING);
    }
    $now = time();
    // First agent was due to expire yesterday.
    $variable = _personalize_agent_get_stoptime_variable('agent-1');
    variable_set($variable, $now - 86400);
    // Second agent is due to expire tomorrow.
    $variable = _personalize_agent_get_stoptime_variable('agent-2');
    variable_set($variable, $now + 86400);

    // Call the function that should pause all agents that are scheduled to be
    // paused.
    personalize_pause_agents();

    // The first agent's status should be paused.
    $this->assertEqual(PERSONALIZE_STATUS_PAUSED, personalize_agent_get_status('agent-1'));
    // The second agent's status should still be running.
    $this->assertEqual(PERSONALIZE_STATUS_RUNNING, personalize_agent_get_status('agent-2'));
    // The third agent's status should still be running.
    $this->assertEqual(PERSONALIZE_STATUS_RUNNING, personalize_agent_get_status('agent-3'));

    $this->drupalLogout();
  }

  function testAgentList() {

    module_disable(array('personalize_test'));
    $this->resetAll();

    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);

    // There should just be a message saying there are no agents.
    $this->drupalGet('admin/structure/personalize');
    $this->assertText(t('No agents available.'));
    $this->assertNoText('Not started');
    $this->assertNoText('Running');
    $this->assertNoText('Paused');
    $this->assertNoText('Completed');

    module_enable(array('personalize_test'));
    $this->resetAll();

    $this->drupalGet('admin/structure/personalize');
    $this->assertNoText(t('No agents available.'));
    // "Not started" should be the only section on the page.
    $this->assertText('Not started');
    $this->assertNoText('Running');
    $this->assertNoText('Paused');
    $this->assertNoText('Completed');
    personalize_agent_set_status('test-agent', PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();
    // There should now be a "Running" section on the page.
    $this->drupalGet('admin/structure/personalize');
    $this->assertNoText(t('No agents available.'));
    $this->assertText('Not started');
    $this->assertText('Running');
    $this->assertNoText('Paused');
    $this->assertNoText('Completed');

    personalize_agent_set_status('test-agent', PERSONALIZE_STATUS_PAUSED);
    personalize_agent_set_status('test-agent-2', PERSONALIZE_STATUS_RUNNING);
    personalize_agent_set_status('test-agent-3', PERSONALIZE_STATUS_RUNNING);
    // There should now be a "Paused" section and a "Running" section only.
    $this->resetAll();
    $this->drupalGet('admin/structure/personalize');
    $this->assertNoText(t('No agents available.'));
    $this->assertNoText('Not started');
    $this->assertText('Running');
    $this->assertText('Paused');
    $this->assertNoText('Completed');
  }

  /**
   * Tests that the cache decision setting is turned on when not specified.
   */
  function testDecisionCacheSetting() {
    $name = $this->randomName();
    $machine_name = personalize_generate_machine_name($name, 'personalize_agent_machine_name_exists');
    $form_values = array(
      'agent_basic_info' => array(
        'machine_name' => $machine_name,
        'title' => $name,
        'agent_type' => 'test_agent',
      )
    );
    personalize_save_agent_from_form_values($form_values);
    $this->resetAll();
    $agent = personalize_agent_load($machine_name);
    $this->assertTrue($agent->data['cache_decisions']);
  }
}

/**
 * Tests administration of agent goals.
 */
class PersonalizeGoalAdminTest extends PersonalizeBaseTest {

  public static function getInfo() {
    return array(
      'name' => t('Personalize Goal Administration'),
      'description' => t('Tests the administration of personalization goals.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test'));
  }

  /**
   * Tests adding and editing goals for a campaign.
   */
  function testAgentGoalEdit() {
    module_enable(array('personalize_test_extra_agent'));

    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);

    $agent = $this->createTestAgent(array('agent_type' => 'test_agent'));
    $agent_name = $agent->getMachineName();

    // Create a new goal
    $this->drupalGet("admin/structure/personalize/manage/{$agent_name}/edit");

    // There should already be an empty goal form on the page.
    $this->assertFieldByName('goals[0][action_name]');
    $edit = array(
      'goals[0][action_name]' => 'user_login',
      'goals[0][value]' => 1,
    );
    $this->drupalPostAJAX(NULL, $edit, array('op' => $this->getButton('goal')), NULL, array(), array(), 'personalize-agent-goals-form');

    // Verify new goal is on page
    $this->drupalGet("admin/structure/personalize/manage/{$agent_name}/edit");
    $this->assertOptionSelected('edit-goals-0-action-name', 'user_login');

    // Add two more goals
    $this->drupalPostAJAX(NULL, array(), array('op' => $this->getButton('add_goal')), NULL, array(), array(), 'personalize-agent-goals-form');
    $this->assertFieldByName('goals[1][action_name]');

    $this->drupalPostAJAX(NULL, array(), array('op' => $this->getButton('add_goal')), NULL, array(), array(), 'personalize-agent-goals-form');
    $this->assertFieldByName('goals[2][action_name]');

    // Save one of them.
    $edit = array(
      'goals[2][action_name]' => 'user_register',
      'goals[2][value]' => 2,
    );
    $this->drupalPostAJAX(NULL, $edit, array('op' => $this->getButton('goal')), NULL, array(), array(), 'personalize-agent-goals-form');

    // Verify that we only have two goals saved on the page now.
    $this->drupalGet("admin/structure/personalize/manage/{$agent_name}/edit");
    $this->assertOptionSelected('edit-goals-0-action-name', 'user_login');
    $this->assertOptionSelected('edit-goals-1-action-name', 'user_register');
    $this->assertNoFieldByName('goals[2][action_name]');

    // Verify that we cannot add goals to agents that do not support them.
    $agent = $this->createTestAgent(array('agent_type' => 'test_extra_agent'));
    $agent_name = $agent->getMachineName();
    try {
      personalize_goal_save($agent_name, 'user_login', 1);
      $this->fail('Should not get here.');
    } catch (Exception $e) {
      $this->assertTrue($e instanceof PersonalizeException);
      $this->assertEqual($e->getMessage(), t('Goals are not supported by this campaign.'));
    }
  }

  /**
   * Tests the integration of automatic goal creation from visitor action
   * forms.
   */
  function testVisitorActionGoalForm() {
    // Enable an agent that does not support goals.
    module_enable(array('personalize_text_extra_agent'));
    $this->resetAll();

    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer visitor actions'));
    $this->drupalLogin($admin_user);

    // Create a new agent that supports goals.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    personalize_set_campaign_context($machine_name);
    $this->drupalGet('admin/structure/visitor_actions/add');
    $this->assertFieldByName('personalize_goal');
    $this->assertFieldByName('personalize_goal_value');
    // Create a goal and verify that it is added to the campaign.
    $goal_name = $this->randomName();
    $edit = array(
      'title' => $goal_name,
      'machine_name' => personalize_generate_machine_name($goal_name),
      'actionable_element' => 'page',
      'event[page]' => 'client::view',
      'pages' => '<front>',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('add_visitor_action'));
    $goals = personalize_goal_load_by_conditions(array('agent' => $machine_name));
    $this->assertEqual(count($goals), 1);

    // Now create an agent that does not support goals.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    personalize_set_campaign_context($machine_name);
    $this->drupalGet('admin/structure/visitor_actions/add');
    $this->assertNoFieldByName('personalize_goal');
    $this->assertNoFieldByName('personalize_goal_value');
  }

}
class PersonalizeMVTAdminTest extends PersonalizeBaseTest {
  public static function getInfo() {
    return array(
      'name' => t('Personalize MVT admin Tests'),
      'description' => t('Tests for administering MVTs.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test'));
  }

  /**
   * Tests creation and editing of multivariate tests.
   */
  function testMVTForms() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[options][test_agent][use_client_side_goal_processing]' => 1,
    );
    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    // Create 4 Option Sets for this agent.
    $osids = array();
    for ($i = 0; $i < 4; $i++) {
      $option_set = new stdClass();
      $option_set->label = $this->randomName(8);
      $option_set->plugin = 'some_type';
      $option_set->agent = $machine_name;
      $option_set->options = array(
        array('option_id' => 'option-A', 'option_label' => 'Option A'),
        array('option_id' => 'option-B', 'option_label' => 'Option B')
      );
      personalize_option_set_save($option_set);
      $osids[] = $option_set->osid;
    }

    // Try creating an MVT with just one option set.
    $mvt_label = $this->randomName();
    $mvt_machine_name = personalize_generate_machine_name($mvt_label, 'personalize_mvt_machine_name_exists');
    $edit = array();
    $edit['mvt[add][mvt_basic_info][label]'] = $mvt_label;
    $edit['mvt[add][mvt_basic_info][option_sets][]'] = array($osids[0]);

    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('mvt'));
    $this->assertText(t('You must choose at least two option sets to create a new multivariate test.'));
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertFalse($mvt);

    // Apparently we need to reset when posting to the same page twice
    // in a row.
    $this->resetAll();
    // Now try with 2 option sets.
    $edit['mvt[add][mvt_basic_info][option_sets][]'] = array($osids[0], $osids[1]);
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('mvt'));

    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(2, count($mvt->option_sets));

    // Remove one of the option sets.
    $option_set = personalize_option_set_load($osids[0], TRUE);
    $option_set->mvt = NULL;
    personalize_option_set_save($option_set);

    $this->resetAll();
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(1, count($mvt->option_sets));

    // Now add a different option set.
    $option_set_3 = personalize_option_set_load($osids[2], TRUE);
    $option_set_3->mvt = $mvt_machine_name;
    personalize_option_set_save($option_set_3);

    $this->resetAll();
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(2, count($mvt->option_sets));

    $this->drupalGet("admin/structure/personalize/manage/{$machine_name}/edit");
    // Confirm that the existing MVT is listed with the two option set names.
    $option_set_2 = personalize_option_set_load($osids[1], TRUE);
    $os_names = array($option_set_2->label, $option_set_3->label);
    $existing_mvt_listing = l('edit', "admin/structure/personalize/mvt/manage/{$mvt_machine_name}/edit");
    $this->assertRaw($existing_mvt_listing);
    // Now go to the edit page for this MVT and add another Option Set
    $edit = array(
      'mvt_basic_info[option_sets][]' => array($osids[1],$osids[2],$osids[3])
    );

    $this->drupalPost("admin/structure/personalize/mvt/manage/{$mvt_machine_name}/edit", $edit, $this->getButton('Save'));

    $this->resetAll();
    $mvt = personalize_mvt_load($mvt_machine_name);
    $this->assertEqual(3, count($mvt->option_sets));
  }

  /**
   * Tests saving and deleting MVTs.
   */
  function testMVTSaveDelete() {
    // Create 4 Option Sets.
    $osids = array();
    for ($i = 0; $i < 4; $i++) {
      $option_set = new stdClass();
      $option_set->label = $this->randomName(8);
      $option_set->plugin = 'some_type';
      $option_set->agent = 'some-agent';
      $option_set->options = array(
        array('option_id' => 'option-A'),
        array('option_id' => 'option-B')
      );
      $option_set = personalize_option_set_save($option_set);
      $osids[] = $option_set->osid;
    }

    // Now create an MVT and add 2 of the Option Sets to it.
    $mvt = new stdClass();
    $mvt->label = 'Test Mvt';
    $mvt->agent = 'test-agent';
    // Only the array keys matter in the option_sets property.
    $mvt->option_sets = array(
      $osids[0] => $osids[0],
      $osids[1] => $osids[1],
    );
    personalize_mvt_save($mvt);

    // Reset all static vars and load all our option sets to
    // confirm that the first 2 have their mvt property set to
    // the new MVT while the others still have a null MVT value.
    drupal_static_reset();
    for ($i = 0; $i < 4; $i++) {
      $option_set = personalize_option_set_load($osids[$i]);
      if ($i < 2) {
        $this->assertEqual('test-mvt', $option_set->mvt);
      }
      else {
        $this->assertNull($option_set->mvt);
      }
    }

    // Now delete the MVT.
    personalize_mvt_delete('test-mvt');
    // Reset all static vars and load all our option sets to
    // confirm that all of them have a null MVT value.
    drupal_static_reset();
    for ($i = 0; $i < 4; $i++) {
      $option_set = personalize_option_set_load($osids[$i]);
      $this->assertNull($option_set->mvt);
    }
  }
}


class PersonalizeAdminSettingsTest extends PersonalizeBaseTest {
  public static function getInfo() {
    return array(
      'name' => t('Personalize Admin Settings Tests'),
      'description' => t('Tests for configuration settings and admin JS settings.'),
      'group' => t('Personalize'),
    );
  }

  function setUp() {
    parent::setUp(array('ctools', 'personalize', 'personalize_test'));
  }

  /**
   * Tests changing personalization configuration settings.
   */
  function testConfigurationSettings() {
    $admin_user = $this->drupalCreateUser(array('administer personalize configuration', 'access administration pages'));
    $this->drupalLogin($admin_user);
    // Set the local storage expiration to 60
    $edit = array(
      'personalize_local_caching_expiration' => 60,
      'personalize_local_caching_storage' => 'local',
    );
    $this->drupalPost('admin/config/content/personalize', $edit, $this->getButton('config'));
    $this->drupalGet('');
    // Assert the correct setting is in the js.
    $settings = $this->drupalGetSettings();
    $this->assertEqual(60, $settings['personalize']['cacheExpiration']['decisions']);

    // Set the local storage to session and leave the expiration to ensure the
    // expiration changes based on storage change only.
    $edit['personalize_local_caching_storage'] = 'session';
    $this->drupalPost('admin/config/content/personalize', $edit, $this->getButton('config'));
    $this->drupalGet('');
    // Assert the correct setting is in the js.
    $settings = $this->drupalGetSettings();
    $this->assertEqual('session', $settings['personalize']['cacheExpiration']['decisions']);
  }

  /**
   * Tests campaign context switching.
   */
  function testCampaignContextAjaxCallbacks() {
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);

    // Create a new agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Get the active context.
    $response = $this->drupalGetAJAX('/personalize/campaign_context/');
    $this->assertEqual($machine_name, $response['personalize_campaign'], 'The new campaign is the active personalize campaign context.');

    // Create another agent via the UI.
    $agent_name = $this->randomName();
    $machine_name = personalize_generate_machine_name($agent_name, 'personalize_agent_machine_name_exists');
    $edit = array(
      'agent_basic_info[title]' => $agent_name,
      'agent_basic_info[machine_name]' => $machine_name,
      'agent_basic_info[agent_type]' => 'test_extra_agent',
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));

    // Set the active context to the new agent.
    $this->drupalGetAJAX('personalize/campaign_context/' . $machine_name);
    // Get the active context.
    $response = $this->drupalGetAJAX('personalize/campaign_context/');
    $this->assertEqual($machine_name, $response['personalize_campaign'], 'The new campaign is the active personalize campaign context.');
  }

  /**
   * Tests campaign javascript settings.
   */
  function testCampaignSettings() {
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Create two agents of different types.
    $first_agent_name = $this->randomName();
    $first_agent_machine_name = personalize_generate_machine_name($first_agent_name, 'personalize_agent_machine_name_exists');
    $second_agent_name = $this->randomName();
    $second_agent_machine_name = personalize_generate_machine_name($second_agent_name, 'personalize_agent_machine_name_exists');
    $agents = array(
      array(
        'label' => $first_agent_name,
        'machine_name' => $first_agent_machine_name,
        'agent_type' => 'test_agent',
      ),
      array(
        'label' => $second_agent_name,
        'machine_name' => $second_agent_machine_name,
        'agent_type' => 'test_extra_agent',
      ),
    );
    foreach ($agents as $agent) {
      $edit = array(
        'agent_basic_info[title]' => $agent['label'],
        'agent_basic_info[machine_name]' => $agent['machine_name'],
        'agent_basic_info[agent_type]' => $agent['agent_type'],
      );
      $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    }
    $expected = array(
      $first_agent_machine_name => array(
        'name' => $first_agent_machine_name,
        'label' => $first_agent_name,
        'type' => 'test_agent',
        'status' => PERSONALIZE_STATUS_NOT_STARTED,
        'nextStatus' => array(
          'status' => PERSONALIZE_STATUS_RUNNING,
          'text' => t('Start'),
        ),
        'links' => array(
          'edit' => base_path() . 'admin/structure/personalize/manage/' . $first_agent_machine_name . '/edit',
          'report' => base_path() . 'admin/structure/personalize/manage/' . $first_agent_machine_name . '/report',
          'view' => base_path() . 'admin/structure/personalize/manage/' . $first_agent_machine_name,
        ),
        'supportsGoals' => TRUE,
        'optionSetTypes' => array(),
        'goals' => NULL,
        'verified' => TRUE,
      ),
      $second_agent_machine_name => array(
        'name' => $second_agent_machine_name,
        'label' => $second_agent_name,
        'type' => 'test_extra_agent',
        'status' => PERSONALIZE_STATUS_NOT_STARTED,
        'nextStatus' => array(
          'status' => PERSONALIZE_STATUS_RUNNING,
          'text' => t('Start'),
        ),
        'links' => array(
          'edit' => base_path() . 'admin/structure/personalize/manage/' . $second_agent_machine_name . '/edit',
          'report' => '',
          'view' => base_path() . 'admin/structure/personalize/manage/' . $second_agent_machine_name,
        ),
        'supportsGoals' => FALSE,
        'optionSetTypes' => array(),
        'goals' => NULL,
        'verified' => TRUE,
      ),
    );
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['personalize']['campaigns'][$first_agent_machine_name], $expected[$first_agent_machine_name]);
    $this->assertEqual($settings['personalize']['campaigns'][$second_agent_machine_name], $expected[$second_agent_machine_name]);

    // Click the "start" button for the first agent.
    $html_id_first_agent = "personalize-toggle-status-{$first_agent_machine_name}-form";
    $this->drupalPost('admin/structure/personalize', array(), t('Start'), array(), array(), $html_id_first_agent);

    $expected[$first_agent_machine_name]['status'] = PERSONALIZE_STATUS_RUNNING;
    $expected[$first_agent_machine_name]['nextStatus'] = array(
      'status' => PERSONALIZE_STATUS_PAUSED,
      'text' => t('Pause'),
    );
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['personalize']['campaigns'][$first_agent_machine_name], $expected[$first_agent_machine_name]);
    $this->assertEqual($settings['personalize']['campaigns'][$second_agent_machine_name], $expected[$second_agent_machine_name]);

    // Add a goal to the agent.
    personalize_goal_save($first_agent_machine_name, 'user_login', 3);
    $this->drupalGet('/');
    $settings = $this->drupalGetSettings();
    $expected[$first_agent_machine_name]['goals'] = array(
      'user_login' => 'logs in',
    );
    $this->assertEqual($settings['personalize']['campaigns'][$first_agent_machine_name], $expected[$first_agent_machine_name]);
    $this->assertEqual($settings['personalize']['campaigns'][$second_agent_machine_name], $expected[$second_agent_machine_name]);
  }

}
