<?php

/**
 * @file personalize.module
 * An API for providing client side personalization on pages based on visitor context.
 */

define('PERSONALIZE_OPTION_SET_CLASS', 'personalize-option-set');
define('PERSONALIZE_OPTION_SET_PREFIX', 'osid-');
define('PERSONALIZE_OPTION_NAME_DATA_ATTR', 'data-personalize-option-name');
define('PERSONALIZE_PRESELECTION_PARAM', 'personalize-preselection');
define('PERSONALIZE_NEW_AGENT_FORM_VALUE', '__new__');
define('PERSONALIZE_MACHINE_NAME_REPLACE_PATTERN', '[^a-z0-9-]+');
define('PERSONALIZE_MACHINE_NAME_MAXLENGTH', 64);
define('PERSONALIZE_CONTEXT_EXPIRATION_CACHE', 'personalize:visitor_context:expiration');
define('PERSONALIZE_AGENT_VERIFY_CACHE', 'personalize:agent:verification');
define('PERSONALIZE_TARGETING_OP_SEPARATOR', '-');
define('PERSONALIZE_TARGETING_ADMIN_SEPARATOR', '__');
define('PERSONALIZE_CONTROL_OPTION_ID', 'control-variation');
define('PERSONALIZE_CONTROL_OPTION_LABEL', 'Control variation');

/**
 * Define constants for campaign status values.
 */
define('PERSONALIZE_STATUS_NOT_STARTED', 1);
define('PERSONALIZE_STATUS_RUNNING', 2);
define('PERSONALIZE_STATUS_PAUSED', 4);
define('PERSONALIZE_STATUS_COMPLETED', 8);

/**
 * =================================================================================
 *  G E N E R A L   D R U P A L   H O O K S   &   R E L A T E D   C A L L B A C K S
 * =================================================================================
 */

/**
 * Implements hook_help().
 */
function personalize_help($path, $arg) {
  switch ($path) {
    case 'admin/help#personalize':
      return t("See the <a href=\"http://drupal.org/project/personalize\">module's home page</a> for a full explanation of how Personalize works and how it can interact with other modules.");
  }
}

/**
 * Implements hook_menu().
 */
function personalize_menu() {
  $items = array();
  $items['admin/config/content/personalize'] = array(
    'type' => MENU_NORMAL_ITEM,
    'title' => 'Personalization settings',
    'description' => 'Configuration settings for the Personalization module and related plugins.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_admin_form'),
    'access arguments' => array('administer personalize configuration'),
    'file' => 'personalize.admin.inc'
  );
  $items['admin/config/content/personalize/general'] = array(
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'title' => 'General',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_admin_form'),
    'access arguments' => array('administer personalize configuration'),
    'file' => 'personalize.admin.inc'
  );
  $items['admin/structure/personalize'] = array(
    'title' => 'Personalize',
    'description' => 'Manage your personalization campaigns.',
    'page callback' => 'personalize_agent_list',
    'access callback' => 'user_access',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/list'] = array(
    'title' => 'Campaigns',
    'description' => 'List personalization agents',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/personalize/add'] = array(
    'title' => 'Add Personalization Campaign',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_agent_form'),
    'access arguments' => array('manage personalized content'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/variations'] = array(
    'title' => 'Variation sets',
    'description' => 'Manage your personalization campaign content variation sets.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_option_set_list'),
    'access callback' => 'user_access',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'personalize.admin.inc',
    'weight' => 10,
  );
  $items['admin/structure/personalize/variations/list'] = array(
    'title' => 'All variation sets',
    'description' => 'Manage all content variation sets for all campaigns.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/personalize/goals'] = array(
    'title' => 'Goals',
    'description' => 'Manage your personalization campaign goals.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_goals_list'),
    'access callback' => 'user_access',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'personalize.admin.inc',
    'weight' => 20,
  );
  $items['admin/structure/personalize/goals/%personalize_goal/delete'] = array(
    'title' => 'Delete Goal',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_admin_goal_delete', 4),
    'access arguments' => array('manage personalized content'),
    'type' => MENU_CALLBACK,
    'file' => 'personalize.admin.inc',
  );
  $items['personalize/campaign_context'] = array(
    'page callback' => 'personalize_get_campaign_context_callback',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_CALLBACK,
    'file' => 'personalize.admin.inc',
  );
  $items['personalize/campaign_context/%personalize_agent'] = array(
    'page callback' => 'personalize_set_campaign_context_callback',
    'access arguments' => array('manage personalized content'),
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/manage/%personalize_agent'] = array(
    'title callback' => 'personalize_campaign_title_callback',
    'title arguments' => array(4),
    'page callback' => 'personalize_agent_page',
    'page arguments' => array(4),
    'access arguments' => array('manage personalized content'),
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/manage/%personalize_agent/edit'] = array(
    'title' => 'Edit campaign',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE,
  );
  $items['admin/structure/personalize/manage/%personalize_agent/report'] = array(
    'title' => 'Report',
    'description' => 'Evaluate your personalization campaign results.',
    'page callback' => 'personalize_campaign_report',
    'page arguments' => array(4, 6),
    'access callback' => 'user_access',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/manage/%personalize_agent/delete'] = array(
    'title' => 'Delete campaign',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_agent_delete_form', 4),
    'access callback' => 'personalize_delete_agent_access',
    'access arguments' => array(4),
    'type' => MENU_CALLBACK,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/manage/%personalize_agent/clone'] = array(
    'title' => 'Clone campaign',
    'page callback' => 'personalize_agent_clone',
    'page arguments' => array(4),
    'access arguments' => array('manage personalized content'),
    //'type' => MENU_LOCAL_TASK,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/manage/%personalize_agent/export'] = array(
    'title' => 'Export',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_agent_export_form', 4),
    'access arguments' => array('manage personalized content'),
    //'type' => MENU_LOCAL_TASK,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/manage/%personalize_agent/ajax_status/%'] = array(
    'page callback' => 'personalize_agent_set_status_ajax',
    'page arguments' => array(4, 6),
    'access callback' => 'user_access',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/structure/personalize/mvt'] = array(
    'title' => 'Personalize: Multivariate Tests',
    'description' => 'Manage your multivariate.',
    'page callback' => 'personalize_mvt_list',
    'access callback' => 'user_access',
    'access arguments' => array('manage personalized content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/mvt/list'] = array(
    'title' => 'MVTs',
    'description' => 'List your multivariate tests',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/personalize/mvt/manage/%personalize_mvt'] = array(
    'title' => 'Edit MVT',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_mvt_form', 5),
    'access arguments' => array('manage personalized content'),
    'file' => 'personalize.admin.inc',
  );
  $items['admin/structure/personalize/mvt/manage/%personalize_mvt/edit'] = array(
    'title' => 'Edit MVT',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );
  $items['admin/structure/personalize/mvt/manage/%personalize_mvt/delete'] = array(
    'title' => 'Delete MVT',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('personalize_mvt_delete_form', 5),
    'access arguments' => array('manage personalized content'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'personalize.admin.inc',
  );
  $items['personalize/option_set/%/%/ajax'] = array(
    'page callback' => 'personalize_option_set_ajax',
    'page arguments' => array(2, 3),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function personalize_permission() {
  $permissions = array(
   'manage personalized content' => array(
      'title' => t('Manage personalized content'),
      'description' => t('Create and edit personalization campaigns with various types of personalized content.'),
    ),
    'administer personalize configuration' => array(
      'title' => t('Administer personalize settings'),
      'description' => t('Administer configuration settings for personalization.'),
    ),
  );

  return $permissions;
}

/**
 * Access callback for agent deletion.
 *
 * @param $agent
 *   An object representing the db record for the agent.
 * @return bool
 *   TRUE if the user has the correct permission and the agent has not yet
 *   started and has no option sets, FALSE otherwise.
 */
function personalize_delete_agent_access($agent) {
  if (!user_access('manage personalized content')) {
    return FALSE;
  }
  $status = personalize_agent_get_status($agent->machine_name);
  $option_sets = personalize_option_set_load_by_agent($agent->machine_name);
  return $status != PERSONALIZE_STATUS_RUNNING && count($option_sets) == 0;
}

/**
 * Implements hook_entity_info().
 */
function personalize_entity_info() {
  return array(
    'personalize_option_set' => array(
      'label' => t('Personalize Option Set'),
      'base table' => 'personalize_option_sets',
      'entity keys' => array(
        'id' => 'osid',
        'uuid' => 'uuid',
      ),
      'uuid' => TRUE,
    ),
    'personalize_campaign_goal' => array(
      'label' => t('Personalize Goals'),
      'base table' => 'personalize_campaign_goals',
      'entity keys' => array(
        'id' => 'id',
        'uuid' => 'uuid',
      ),
      'uuid' => TRUE,
    ),
  );
}

/**
 * Implements hook_cron().
 */
function personalize_cron() {
  personalize_pause_agents();
}

/**
 * Pauses any agent that is due to be paused.
 */
function personalize_pause_agents() {
  $all_agents = personalize_agent_load_multiple();
  foreach ($all_agents as $agent_name => $agent) {
    $status = personalize_agent_get_status($agent_name);
    if ($status == PERSONALIZE_STATUS_RUNNING) {
      if (personalize_agent_stop_now($agent)) {
        personalize_agent_set_status($agent_name, PERSONALIZE_STATUS_PAUSED);
        watchdog('personalize', 'Pausing agent @agent via cron', array('@agent' => $agent_name));
      }
    }
  }
}

/**
 * Returns whether or not the passed in agent is due to be paused.
 *
 * @param $agent_data
 *   An object representing the agent.
 * @return bool
 *   TRUE if the agent is due to be paused, FALSE otherwise.
 */
function personalize_agent_stop_now($agent_data) {
  // First check if a variable has been set specifying a timestamp for
  // when this agent should be paused.
  $variable = _personalize_agent_get_stoptime_variable($agent_data->machine_name);
  $stop_time = variable_get($variable, 0);
  if ($stop_time > 0) {
    $ts = time();
    if ($ts >= $stop_time) {
      return TRUE;
    }
    else {
      // Hasn't reached the scheduled stop time yet.
      return FALSE;
    }
  }
  // Otherwise the agent plugin might have some logic for determining whether
  // it should be stopped.
  if ($agent = personalize_agent_load_agent($agent_data->machine_name)) {
    return $agent->stopNow();
  }
  return FALSE;
}

/**
 * Implements hook_page_build().
 */
function personalize_page_build(&$page) {
  // Add the necessary JavaScript settings for personalization.
  $settings = array(
    'optionPreselectParam' => PERSONALIZE_PRESELECTION_PARAM,
    'controlOptionName' => PERSONALIZE_CONTROL_OPTION_ID,
    'controlOptionLabel' => PERSONALIZE_CONTROL_OPTION_LABEL,
  );

  // cacheExpiration keys should match web storage bucket names.
  // @see js/personalize.js
  // Get the cache settings for visitor contexts.
  $settings['cacheExpiration'] = personalize_visitor_context_expiration_load();
  // Add in the decision caching expiration settings.
  $settings['cacheExpiration']['decisions'] = variable_get('personalize_local_caching_storage', 'session') == 'session' ? 'session' : variable_get('personalize_local_caching_expiration', 30);

  // Check if a pre-selection for one or more option sets has been
  // passed in the querystring.
  if (isset($_GET[PERSONALIZE_PRESELECTION_PARAM])) {
    $preselected = explode(',', $_GET[PERSONALIZE_PRESELECTION_PARAM]);
    foreach ($preselected as $option_str) {
      list($osid_str, $selection) = explode('--', trim($option_str));
      // Make sure this is a valid option set.
      $osid = personalize_resolve_stringified_osid($osid_str);
      if (!$osid) {
        continue;
      }
      if ($option_set = personalize_option_set_load($osid)) {
        foreach ($option_set->options as $option) {
          if ($option['option_id'] === $selection) {
            $settings['preselected'][$osid_str] = $option['option_id'];
            break;
          }
        }
      }
    }
  }
  if ($active_campaign = personalize_get_campaign_context()) {
    $settings['activeCampaign'] = $active_campaign;
  }

  global $user;
  if ($user->uid > 0) {
    // If this is an administrator, add an admin mode setting so that
    // no interactions happen with decision agents.
    if (personalize_admin_mode()) {
      $settings['adminMode'] = TRUE;
    }
    else {
      // Use a simple hash of the user ID as the session ID for personalization.
      $settings['sessionID'] = sha1('drupal-personalize' . variable_get('site_name', 'Drupal') . $user->uid);
    }
  }
  if (user_access('manage personalized content')) {
    // Provide the status constants
    $settings['status'] = personalize_get_agent_status_map();
    $settings['campaigns'] = personalize_agent_get_settings();
  }

  $page['page_top']['personalization'] = array(
    '#attached' => array(
      'js' => array(
        array(
          'data' => array('personalize' => $settings),
          'type' => 'setting'
        ),
      ),
      'library' => array(
        array('personalize', 'personalize'),
      ),
    )
  );
  // Process any goals that have been set. This needs to happen when a page is
  // actually being built in preparation for rendering so that there is
  // little chance of a redirect happening, but it can't be so late that
  // JavaScript files can't be added to the page.
  personalize_process_goals($page);
}

/**
 * Generate an array of campaign settings that are currently configured.
 * This administrative information is used for navigation and campaign
 * management.
 *
 * @return array
 *   An array of campaigns keyed by machine_name.
 */
function personalize_agent_get_settings() {
  $campaigns = array();
  // We need to provide information about all configured campaigns
  // and goals for the control UI.
  $actions = visitor_actions_get_actions();
  // List the campaigns in Drupal.settings, excluding completed campaigns.
  foreach (personalize_agent_load_multiple(array(), array(), FALSE, FALSE, 'label') as $agent) {
    $plugin = personalize_agent_load_agent($agent->machine_name);
    if (!$plugin) {
      continue;
    }
    $supports_goals = $plugin instanceof PersonalizeAgentGoalInterface;
    if ($supports_goals) {
      foreach (personalize_goal_load_by_conditions(array('agent' => $agent->machine_name)) as $goal) {
        if (isset($actions[$goal->action])) {
          $goals[$goal->action] = check_plain($actions[$goal->action]['label']);
        }
      }
    }
    $current_status = personalize_agent_get_status($agent->machine_name);
    list($next_status, $status_text) = _personalize_status_toggle_next($current_status);
    $verified = _personalize_agent_verification_cache_get($agent->machine_name);
    $option_sets = personalize_option_set_load_by_agent($agent->machine_name);
    $option_set_types = array();
    foreach ($option_sets as $option_set) {
      $option_set_types[] = $option_set->plugin;
    }
    $campaigns[$agent->machine_name] = array(
      'name' => $agent->machine_name,
      'label' => check_plain($agent->label),
      'type' => $agent->plugin,
      'status' => $current_status,
      'nextStatus' => array(
        'status' => $next_status,
        'text' => $status_text,
      ),
      'links' => array(
        'view' => base_path() . 'admin/structure/personalize/manage/' . $agent->machine_name,
        'edit' => base_path() . 'admin/structure/personalize/manage/' . $agent->machine_name . '/edit',
        'report' => $plugin instanceof PersonalizeAgentReportInterface && $verified ? base_path() . 'admin/structure/personalize/manage/' . $agent->machine_name . '/report' : '',
      ),
      'supportsGoals' => $supports_goals,
      'optionSetTypes' => array_unique($option_set_types),
      'goals' => (isset($goals)) ? $goals : NULL,
      'verified' => $verified,
    );
    // In the client, goals will render to an array when it is empty and an
    // object when it has data, so the no-data state must be NULL to keep
    // the type consistent as an object.
    unset($goals);
  }
  return $campaigns;
}

/**
 * Generate the agent map settings for an agent.
 */
function personalize_agent_get_map_settings($agent_name, $option_set = NULL, &$assets = array()) {
  $agent = personalize_agent_load_agent($agent_name);
  // Bail if for some reason the agent could not be instantiated.
  if (!$agent) {
    return;
  }

  $assets = array_merge_recursive($assets, $agent->getAssets());
  $data = $agent->getData();
  // Add visitor context assets.
  $visitor_context = array();

  // Find the possible visitor context based on the agent (auto-targeting) and
  // on the selected option set's options (fixed targeting).
  $all_contexts = !empty($data['visitor_context']) ? $data['visitor_context'] : array();
  // If no option set passed, then just get the contexts for all.
  $option_sets = empty($option_set) ? personalize_option_set_load_by_agent($agent_name) : array($option_set);
  foreach ($option_sets as $option_set) {
    foreach ($option_set->options as $option) {
      if (!empty($option['fixed_targeting_rules'])) {
        foreach($option['fixed_targeting_rules'] as $rule) {
          // Doesn't matter if we overwrite an existing value as they are all the
          // same key/value pairs.
          $all_contexts[$rule['plugin']][$rule['context']] = $rule['context'];
        }
      }
    }
  }

  foreach ($all_contexts as $name => $contexts) {
    $selected_context = array_filter($contexts);
    if (!empty($selected_context) && $class = ctools_plugin_load_class('personalize', 'visitor_context', $name, 'handler')) {
      if ($plugin = call_user_func_array(array($class, 'create'), array($agent, array_keys($selected_context)))) {
        // Ensure js assets for visitor_context plugins are loaded.
        $assets = array_merge_recursive($assets, $plugin->getAssets());
        // Keep track of which visitor_context plugins are enabled for this agent.
        $visitor_context[$name] = $selected_context;
      }
    }
  }

  return array(
    'type' => $agent->getType(),
    'label' => check_plain($agent->getTitle()),
    // We just need a boolean indicating whether or not the campaign is
    // currently running.
    'active' => $agent->getStatus() & PERSONALIZE_STATUS_RUNNING,
    'enabled_contexts' => $visitor_context,
    'cache_decisions' => isset($data['cache_decisions']) && $data['cache_decisions'],
  );
}

/**
 * Implements hook_overlay_child_initialize().
 */
function personalize_overlay_child_initialize() {
  $page = array();
  personalize_page_build($page);
  if (!isset($page['page_top']['personalization']['#attached'])) {
    return;
  }
  drupal_process_attached($page['page_top']['personalization']);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function personalize_form_visitor_actions_form_alter(&$form, &$form_state) {
  if ($campaign = personalize_get_campaign_context()) {
    $agent_instance = personalize_agent_load_agent($campaign);
    if (!($agent_instance instanceof PersonalizeAgentGoalInterface)) {
      // This agent doesn't support goals.
      return;
    }
    $form['advanced']['personalize_goal'] = array(
      '#type' => 'checkbox',
      '#title' => t('Add as a goal to the @campaign campaign', array('@campaign' => $campaign)),
      '#default_value' => 1,
    );
    $form['advanced']['personalize_goal_value'] = array(
      '#type' => 'textfield',
      '#title' => t('Goal value'),
      '#description' => t('The relative value of this goal in the campaign'),
      '#size' => 6,
      '#default_value' => '1',
      '#states' => array(
        'visible' => array(
          ':input[name="personalize_goal"]' => array('checked' => TRUE),
        ),
      ),
    );
    $form['personalize_campaign'] = array(
      '#type' => 'value',
      '#value' => $campaign,
    );
    $form['#submit'][] = 'personalize_visitor_action_form_submit';
  }
}

/**
 * Submit callback for the user action creation form.
 *
 * Adds the new action as a goal on the current campaign if the
 * personalize_goal checkbox was checked.
 */
function personalize_visitor_action_form_submit($form, &$form_state) {
  $values = $form_state['values'];
  if (isset($values['personalize_campaign']) && isset($values['personalize_goal']) && $values['personalize_goal']) {
    try {
      personalize_goal_save($values['personalize_campaign'], $values['machine_name'], $values['personalize_goal_value']);
    }
    catch (Exception $e) {
      drupal_set_message($e->getMessage(), 'error');
    }
  }
}

/**
 * Implements hook_forms().
 */
function personalize_forms() {
  $forms = array();
  // We need a status toggle form for each agent on the site.
  foreach (personalize_agent_load_multiple(array(), array(), TRUE, TRUE) as $agent) {
    $forms["personalize_toggle_status_{$agent->machine_name}_form"]['callback'] = 'personalize_status_toggle_form';
  }
  return $forms;
}

/**
 * Title callback for the campaign admin UI.
 *
 * @param $agent_data
 *   The agent being edited.
 * @return string
 *   The title to use for the page.
 */
function personalize_campaign_title_callback($agent_data) {
  $title = isset($agent_data->label) ? check_plain($agent_data->label) : $agent_data->machine_name;
  return $title;
}


/**
 * Implements hook_element_info().
 */
function personalize_element_info() {
  return array(
    'personalize_admin_section' => array(
      '#theme_wrappers' => array('personalize_admin_section'),
    ),
    'personalize_admin_content' => array(
      '#theme_wrappers' => array('personalize_admin_content'),
      '#title' => '',
      '#collapsible' => 0,
      '#pre_render' => array('personalize_pre_render_admin_content'),
    ),
    'personalize_content_set_item' => array(
      '#theme_wrappers' => array('personalize_content_set_item'),
      '#title' => '',
    ),
  );
}

/**
 * Implements hook_library().
 */
function personalize_library() {
  $path = drupal_get_path('module', 'personalize');
  $options = array(
    'scope' => 'footer',
    'defer' => TRUE,
  );

  $libraries = array();
  $libraries['admin.campaign'] = array(
    'title' => 'Campaign edit',
    'website' => '',
    'version' => VERSION,
    'js' => array(
      $path . '/js/personalize.admin.js' => $options,
    ),
    'css' => array(
      $path . '/css/personalize.theme.css' => array(),
      $path . '/css/personalize.admin.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'jquery.once'),
    ),
  );
  $libraries['personalize'] = array(
    'title' => 'Personalize capabilities',
    'website' => '',
    'version' => VERSION,
    'js' => array(
      $path . '/js/promise-1.0.0.min.js' => $options,
      $path . '/js/personalize.js' => $options,
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'jquery.once'),
      array('system', 'jquery.cookie'),
      array('system', 'jquery.bbq'),
      array('system', 'drupal.ajax'),
    )
  );
  return $libraries;
}

/**
 * A custom page delivery callback to allow processing on any AJAX commands that
 * are sent as page ajax content.
 *
 * @param $commands
 *   An array of AJAX commands to be returned.
 * @param $return_output
 *   True to return the updated page output for custom rendering, false to
 *   render via Drupal AJAX delivery.
 */
function personalize_ajax_commands_deliver($commands, $return_output = FALSE) {
  // Advagg module removes any merged settings from the ajax delivery so we
  // need to handle them specially if this module is enabled.
  if (module_exists('advagg')) {
    foreach ($commands as &$command) {
      if ($command['command'] == 'settings'
        && is_array($command['settings'])
        && !empty($command['merge'])) {
        $command['command'] = 'personalize_settings_merge';
      }
    }
  }
  $page = array('#type' => 'ajax', '#commands' => $commands);
  if ($return_output) {
    return $page;
  }
  // Otherwise just process it as AJAX content.
  ajax_deliver($page);
}

/**
 * =======================================================================
 *  T H E M E   I N F O
 * =======================================================================
 */

/**
 * Implements hook_theme()
 */
function personalize_theme($existing, $type, $theme, $path) {
  $path = drupal_get_path('module', 'personalize');
  return array(
    'personalize_options_wrapper' => array(
      'render element'  => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
    ),
    'personalize_options_callback_wrapper' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
    ),
    'personalize_html_tag' => array(
      'render element'  => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
    ),
    'personalize_admin_section' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
      'template' => 'personalize-admin-section',
    ),
    'personalize_admin_content' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
    ),
    'personalize_admin_info_details' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
    ),
    'personalize_content_set_item' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
      'template' => 'personalize-content-set-item',
    ),
    'personalize_campaign_status_update' => array(
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
      'variables' => array(
          'option_message' => '',
          'option_sets' => array(),
      ),
    ),
    'personalize_option_set_report' => array(
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
      'variables' => array(
        'report' => '',
      ),
    ),
    'personalize_admin_enumerated_item' => array(
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
      'variables' => array(
        'enum' => '',
        'title' => '',
        'title_prefix' => '',
        'title_suffix' => '',
        'attributes' => array(),
      ),
    ),
    'personalize_option_set_header' => array(
      'path' => $path . '/theme',
      'file' => 'personalize.theme.inc',
      'variables' => array(
        'variation_count' => 0,
        'report' => array(),
        'report_link' => '',
      ),
    ),
  );
}

/**
 * Implements hook_preprocess_HOOK().
 */
function personalize_preprocess_node(&$variables) {
  if (isset($variables['elements']['#personalize'])) {
    $node = $variables['elements']['#node'];
    $variables['attributes_array']['data-personalize-entity-id'] = 'node/' . $node->nid;
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function personalize_preprocess_block(&$variables) {
  if (module_exists('personalize_blocks')) {
    $block = $variables['elements']['#block'];
    $variables['attributes_array']['data-personalize-entity-id'] = 'block/' . $block->bid;
  }
}

/**
 * =======================================================================
 *  P E R S O N A L I Z E  A P I
 * =======================================================================
 */

/**
 * Helper function to sort an array of objects based on a property within
 * each object.
 *
 * @param array $objects
 *   An array of "object"/associative arrays.
 * @param string $sort
 *   Either the name of the property to sort by or a function to use for
 *   comparison.
 */
function _personalize_loaded_object_sort(&$objects, $sort) {
  if (!empty($sort)) {
    if (function_exists($sort)) {
      uasort($objects, $sort);
    }
    else {
      uasort($objects, function($a, $b) use($sort) {
        if (isset($a->{$sort}) && isset($b->{$sort})) {
          if ($a->{$sort} == $b->{$sort}) {
            return 0;
          }
          if (is_numeric($a->{$sort}) && is_numeric($b->{$sort})) {
            ($a->{$sort} < $b->{$sort}) ? -1 : 1;
          }
          else {
            return strcmp(drupal_strtolower($a->{$sort}), drupal_strtolower($b->{$sort}));
          }
        }
        return 0;
      });
    }
  }
}

/**
 * Performs necessary asset loading for an element being rendered with
 * personalization.
 *
 * @param $element
 *   The element being rendered.
 * @param $option_set
 *   The Option Set the element corresponds to.
 */
function personalize_element_with_option_set(&$element, $option_set, $skip_completed = FALSE) {
  $loaded_mvts = &drupal_static(__FUNCTION__, array());
  $attached = isset($element['#attached']) ? $element['#attached'] : array();
  $agent_name = $option_set->agent;
  if ($skip_completed && personalize_agent_get_status($agent_name) === PERSONALIZE_STATUS_COMPLETED) {
    return;
  }

  if (isset($option_set->mvt) && !in_array($option_set->mvt, $loaded_mvts) && $mvt = personalize_mvt_load($option_set->mvt)) {
    $loaded_mvts[] = $option_set->mvt;
    if (count($mvt->option_sets) > 1) {
      // Always use the agent specified in the MVT rather than the Option
      // Set's agent, in case these are somehow different.
      $agent_name = $mvt->agent;
      $settings = (array) $mvt;
      $settings['option_sets'] = array();
      foreach ($mvt->option_sets as $os) {
        $os->stateful = $mvt->stateful;
        $settings['option_sets'] += _personalize_convert_option_set_to_js_setting($os);
      }
      $mvt_settings = array(
        $mvt->machine_name => $settings
      );
    }
  }

  // Now add a js setting to map the agent name to information about its type
  // and enabled visitor contexts.
  if (!isset($assets['js'])) {
    $assets['js'] = array();
  }
  $personalize_settings = array(
    'type' => 'setting',
    'data' => array(
      'personalize' => array(
        'agent_map' => array(
          $agent_name => personalize_agent_get_map_settings($agent_name, $option_set, $assets),
        ),
        'option_sets' => _personalize_convert_option_set_to_js_setting($option_set)
      )
    )
  );
  if (isset($mvt_settings)) {
    $personalize_settings['data']['personalize']['mvt'] = $mvt_settings;
  }
  $assets['js'] = array_merge_recursive($assets['js'], array($personalize_settings));
  foreach ($assets as $type => $data_array) {
    if (!isset($attached[$type])) {
      $attached[$type] = array();
    }
    $attached[$type] = array_merge($attached[$type], $data_array);
  }

  // Mark the entity as being personalized.
  $element['#personalize'] = (isset($element['#entity_type'])) ? $element['#entity_type'] : NULL;
  $element['#attached'] = $attached;
}

/**
 * Helper function to determine the variable name to use for a campaign's status
 * variable.
 *
 * @param $agent_name
 *   The name of the campaign to use for name generation.
 */
function _personalize_agent_get_status_variable($agent_name) {
  return "personalize_campaign_{$agent_name}_status";
}

/**
 * Helper function to determine the variable name to use for a campaign's stop
 * time variable.
 *
 * @param $agent_name
 *   The name of the campaign to use for name generation.
 */
function _personalize_agent_get_stoptime_variable($agent_name) {
  return "personalize_campaign_{$agent_name}_stop";
}

/**
 * Helper function to determine the next status and text to display for
 * changing an agent's status.
 *
 * @param $current_status
 *   The current status of the agent.
 * @return
 *   An array with two values:
 *   - new status value
 *   - text to display
 */
function _personalize_status_toggle_next($current_status) {
  switch ($current_status) {
    case PERSONALIZE_STATUS_NOT_STARTED:
      $new_status = PERSONALIZE_STATUS_RUNNING;
      $button_text = t('Start');
      break;
    case PERSONALIZE_STATUS_PAUSED:
      $new_status = PERSONALIZE_STATUS_RUNNING;
      $button_text = t('Resume');
      break;
    case PERSONALIZE_STATUS_RUNNING:
      $new_status = PERSONALIZE_STATUS_PAUSED;
      $button_text = t('Pause');
      break;
    default:
      $new_status = FALSE;
      $button_text = '';
  }
  return array($new_status, $button_text);
}

/**
 * Ajax callback to update an agent status.
 *
 * @param $agent
 *   The agent to update.
 * @param $status
 *   The new status to set.
 */
function personalize_agent_set_status_ajax($agent, $status) {
  $updated = personalize_agent_set_status($agent->machine_name, $status);
  $return = array('success' => $updated);
  if ($updated) {
    list($next_status, $text) = _personalize_status_toggle_next($status);
    $return['nextStatus'] = array(
      'status' => $next_status,
      'text' => $text,
    );
    $return['currentStatus'] = $status;
  }
  return drupal_json_output($return);
}

/**
 * Set the status of an agent.
 *
 * @param $agent_name
 *   The agent whose status is to be set.
 * @param $status
 *   The status to set.
 *
 * @return boolean
 *   TRUE if the status was set on the agent, FALSE otherwise.
 */
function personalize_agent_set_status($agent_name, $status) {
  $allowed_status = array(
    PERSONALIZE_STATUS_NOT_STARTED,
    PERSONALIZE_STATUS_RUNNING,
    PERSONALIZE_STATUS_PAUSED,
    PERSONALIZE_STATUS_COMPLETED,
  );
  if (!in_array($status, $allowed_status)) {
    watchdog('personalize', 'Attempt to set an agent to an invalid status');
    return FALSE;
  }
  $old_status = personalize_agent_get_status($agent_name);
  if (!$old_status) {
    return FALSE;
  }

  if ($old_status == $status) {
    return TRUE;
  }

  if ($status == PERSONALIZE_STATUS_COMPLETED) {
    // Register the end time of the campaign.
    $end_time_var = _personalize_agent_get_stoptime_variable($agent_name);
    $now = time();
    variable_set($end_time_var, $now);
  }

  if ($status == PERSONALIZE_STATUS_RUNNING) {
    // Do a check before setting the status to running.
    if (!personalize_verify_agent($agent_name)) {
      drupal_set_message(t('There is a problem with this campaign and it cannot be run at this time.'), 'error');
      return FALSE;
    }
    // If we're setting a campaign to the running status for the first time,
    // record the current time as the "started" property of the agent.
    if ($old_status == PERSONALIZE_STATUS_NOT_STARTED) {
      $agent = personalize_agent_load($agent_name);
      $agent->started = time();
      personalize_agent_save($agent);
    }
  }

  // Set the new status in variables.
  variable_set(_personalize_agent_get_status_variable($agent_name), $status);

  if ($old_status == PERSONALIZE_STATUS_COMPLETED) {
    // Remove the variable holding the end time of the campaign.
    variable_del(_personalize_agent_get_stoptime_variable($agent_name));
  }

  // Clear the visitor context cache settings for running campaigns.
  personalize_visitor_context_expiration_clear();

  // Clear the agent's verification status.
  _personalize_agent_verification_cache_clear($agent_name);

  // Allow modules to act on the fact that this agent's status has changed.
  module_invoke_all('personalize_agent_update_status', $agent_name, $old_status, $status);
  return TRUE;
}

/**
 * Runs various checks to make sure the agent is good to go.
 *
 * @param string $agent_name
 *   The name of the agent.
 * @param bool $show_messages
 *   True if any verification errors should be shown using on-screen messages.
 *
 * @return bool
 *   Whether or not the agent passed all the checks.
 */
function personalize_verify_agent($agent_name, $show_messages = TRUE) {
  // Check the option sets to make sure they are all valid.
  $option_sets = personalize_option_set_load_by_agent($agent_name);
  $decisions = array();
  foreach ($option_sets as $osid => $option_set) {
    if (isset($decisions[$option_set->decision_name])) {
      if (count($decisions[$option_set->decision_name]) != count($option_set->options)) {
        // Option Sets using the same decision name must have the same number of options.
        if ($show_messages) {
          drupal_set_message(t('The Option Set @title has @count options but uses the decision @decision which requires @count2 options', array(
            '@title' => $option_set->label,
            '@count' => count($option_set->options),
            '@decision' => $option_set->decision_name,
            '@count2' => count($decisions[$option_set->decision_name]))), 'error');
        }
        return FALSE;
      }
      // The option IDs of the Option Sets must also be the same.
      foreach ($option_set->options as $option) {
        if (!in_array($option['option_id'], $decisions[$option_set->decision_name])) {
          if ($show_messages) {
            drupal_set_message(t('The Option Set @title uses the decision @decision but has different option IDs. Option IDs cannot be changed so you will need to delete the options and recreate them.', array(
              '@title' => $option_set->label,
              '@decision' => $option_set->decision_name)), 'error');
          }
          return FALSE;
        }
      }
    }
    else {
      // Store this decision name to check subsequent Option Sets against.
      $decisions[$option_set->decision_name] = array();
      foreach ($option_set->options as $option) {
        $decisions[$option_set->decision_name][] = $option['option_id'];
      }
    }
  }
  // Now allow the agent to run a check.
  $agent_instance = personalize_agent_load_agent($agent_name);
  if ($agent_instance instanceof PersonalizeAgentInterface) {
    $errors = $agent_instance->errors();
  }
  else {
    $errors[] = t('The agent @agent_name is not a valid PersonalizeAgentInterface implementation.', array('@agent_name' => $agent_name));
  }
  if (!empty($errors)) {
    if ($show_messages) {
      foreach ($errors as $error) {
        drupal_set_message($error, 'error');
      }
    }
    return FALSE;
  }
  return TRUE;
}

/**
 * Returns the current status of the specified agent.
 *
 * @param $agent_name
 *   The name of the agent to return status for.
 * @return mixed
 *   An integer representing the status of the agebtn.
 */
function personalize_agent_get_status($agent_name) {
  $status = variable_get(_personalize_agent_get_status_variable($agent_name), PERSONALIZE_STATUS_NOT_STARTED);
  return $status;
}

/**
 * Returns whether or not we are in admin mode.
 *
 * @return bool
 *   TRUE if set to use admin mode and the current user is admin, FALSE
 *   otherwise.
 */
function personalize_admin_mode() {
  return variable_get('personalize_use_admin_mode', TRUE) && user_access('manage personalized content');
}

/**
 * Sets a warning message if the passed in agent is running.
 *
 * @param $agent_name
 *   The name of the agent.
 */
function personalize_warn_if_running($agent_name) {
  $status = personalize_agent_get_status($agent_name);
  if ($status & PERSONALIZE_STATUS_RUNNING) {
    drupal_set_message(t('You are editing content in a running personalization campaign, which may affect the integrity of the campaign data. The campaign will be paused if you make changes here.'), 'warning');
  }
}

/**
 * Pauses the passed in agent if it's running.
 *
 * @param $agent_name
 *   The name of the agent.
 */
function personalize_pause_if_running($agent_name) {
  $status = personalize_agent_get_status($agent_name);
  if ($status & PERSONALIZE_STATUS_RUNNING) {
    personalize_agent_set_status($agent_name, PERSONALIZE_STATUS_PAUSED);
    $campaign_url = "admin/structure/personalize/manage/{$agent_name}/edit";
    $current_path = current_path();
    $destination_path = isset($_GET['destination']) ? $_GET['destination'] : $current_path;
    if ($current_path !== $campaign_url && $destination_path != $campaign_url) {
      drupal_set_message(t('The campaign has been paused because you have made changes. You can edit and restart the campaign !here or from the Acquia Lift campaign management bar.', array('!here' => l('here', $campaign_url))), 'warning');
    }
    else {
      module_load_include('inc', 'personalize', 'personalize.admin');
      drupal_set_message(t('The campaign has been paused because you have made changes.'));
      personalize_status_toggle_message($agent_name, PERSONALIZE_STATUS_PAUSED);
    }
  }
}

/**
 * Returns an agent selection form element for use in option set forms.
 *
 * @param string $default
 *   Which agent should be selected by default.
 * @param bool $allow_add_new
 *   Whether to include the "Add new" option in the dropdown and the fields for
 *   new agent creation.
 * @return array
 *   An array defining the agent dropdown form element and elements required
 *   to create a new agent, hidden with #states until "Add new" is selected
 *   from the dropdown.
 */
function personalize_get_agent_selection_form($default = '', $allow_add_new = TRUE) {
  if (!user_access('manage personalized content')) {
    // As this form can be embedded in other forms, we do an access
    // check here to make sure only users with the correct permission
    // can use it to create agents.
    return array();
  }
  $form = array();
  $form['personalize'] = array(
    '#type' => 'fieldset',
    '#title' => 'Personalization',
    '#weight' => -99,
    '#tree' => FALSE,
  );
  // Load available agents and put them in an options array.
  $agents = personalize_agent_load_multiple(array(), array(), FALSE, FALSE);
  $agent_options = array();
  foreach($agents as $agent) {
    $agent_options[$agent->machine_name] = check_plain($agent->label);
  }
  if ($allow_add_new) {
    $agent_options[PERSONALIZE_NEW_AGENT_FORM_VALUE] = '< ' . t('Add a new campaign...') . ' >';
  }

  if (empty($default) && $active_campaign = personalize_get_campaign_context()) {
    $default = $active_campaign;
  }

  //  First create a drop down which will include an option to add a new campaign.
  $form['personalize']['agent_select'] = array(
    '#type' => 'select',
    '#title' => 'Campaign',
    '#options' => $agent_options,
    '#description' => t('Select the campaign to use for personalization.'),
    '#default_value' => $default,
  );
  if ($allow_add_new) {
    // Now get the basic form elements for adding a new campaign. We'll use #states
    // to make these hidden until the 'Add a new campaign' option is selected from
    // the dropdown.
    module_load_include('inc', 'personalize', 'personalize.admin');
    $new_campaign_elements = personalize_agent_build_basic_form(NULL, FALSE);
    $children = element_children($new_campaign_elements['agent_basic_info']);
    foreach ($children as $child) {
      // Add a state to the form elements to make sure they only appear when the
      // "Add new" option is selected from teh dropdown.
      $state = array(':input[name="agent_select"]' => array('value' => PERSONALIZE_NEW_AGENT_FORM_VALUE));
      personalize_form_element_add_states($state, $new_campaign_elements['agent_basic_info'][$child]);

    }
    $form['personalize'] += $new_campaign_elements;
  }
  return $form;
}

/**
 * Saves an agent as defined in the 'agent_basic_info' section of a form.
 *
 * This is used in conjunction with the personalize_get_agent_selection_form()
 * function, to save a new agent that was created using that dropdown. The
 * function responsible for building the original form that includes an
 * agent dropdown is also responsible for calling this function to save the
 * values it receives on submission.
 *
 * @param $values
 *   An array corresponding to $form_state['values'] of a submitted form.
 *
 * @return bool|stdClass
 *   The saved agent or FALSE if the agent couldn't be saved.
 */
function personalize_save_agent_from_form_values($values) {
  if (!isset($values['agent_basic_info'])) {
    return FALSE;
  }
  if (!isset($values['agent_basic_info']['machine_name'])) {
    $name = $values['agent_basic_info']['title'];
    $machine_name = personalize_generate_machine_name($name, 'personalize_agent_machine_name_exists');
    $values['agent_basic_info']['machine_name'] = $machine_name;
  }
  module_load_include('inc', 'personalize', 'personalize.admin');
  $agent = _personalize_agent_from_form_values($values['agent_basic_info']);
  personalize_agent_save($agent);
  return $agent;
}

/**
 * Returns an option ID to use for the given option index.
 *
 * @param $index
 *   The index of the Option we're generating an ID for.
 *
 * @return
 *   The option ID to be used.
 */
function personalize_generate_option_id($index) {
  return 'option-' . _personalize_generate_option_index($index);
}

/**
 * Returns a default Option Name.
 *
 * @param $index
 *   The index of the Option we're generating a name for.
 * @return
 *   The option name to be used.
 */
function personalize_generate_option_label($index) {
  return 'Option ' . _personalize_generate_option_index($index);
}

/**
 * Returns a set of options with unique IDs.
 *
 * @param array $options
 *   An array of option arrays.
 * @return array
 *   An array option arrays, each with a unique option_id value.
 */
function personalize_ensure_unique_option_ids($options) {
  $ids = array();
  // First map option IDs to deltas.
  foreach ($options as $delta => &$option) {
    if (isset($option['option_id'])) {
      // Ensure existing option IDs are clean.
      $option['option_id'] = preg_replace('/[^a-zA-Z0-9_-]/', '-', $option['option_id']);
      if (!isset($ids[$option['option_id']])) {
        $ids[$option['option_id']] = $delta;
      }
    }
  }
  // Now create a new option ID for any option that doesn't have
  // one or has a duplicate one.
  foreach ($options as $delta => &$option) {
    if (isset($option['option_id']) && $delta === $ids[$option['option_id']]) {
      // The option ID is fine, do nothing.
      continue;
    }
    if (isset($option['option_id'])) {
      $option_id = $option['option_id'];
    }
    elseif (isset($option['option_label'])) {
      $option_id = personalize_generate_machine_name($option['option_label']);
    }
    else {
      $option_id = personalize_generate_option_id($delta);
    }
    $index = $delta;
    while (in_array($option_id, array_keys($ids))) {
      $option_id = personalize_generate_option_id($index++);
    }
    $option['option_id'] = $option_id;
    $ids[$option_id] = $delta;
  }
  return $options;
}

/**
 * Returns a human-readable name for a decision point.
 *
 * A decision point always corresponds to either an Option Set or a
 * Multivariate test, so this will return the label of the Option Set or
 * MVT.
 *
 * @param string $point_name
 *   The name of the decision point to return a label for.
 *
 * @return string
 *   A human-readable name or the passed in string if none can be found.
 */
function personalize_get_label_for_decision_point_name($point_name) {
  if (preg_match("/osid\-(\d+)/", $point_name, $matches)) {
    $osid = $matches[1];
    if ($option_set = personalize_option_set_load($osid)) {
      return check_plain($option_set->label);
    }
  }
  if ($mvt = personalize_mvt_load($point_name)) {
    return check_plain($mvt->label);
  }
  return $point_name;
}

/**
 * Returns a human-readable name for an option in a given decision.
 *
 * @param string $decision_name
 *   The name of the decision the option belongs to.
 * @param string $option_id
 *   The option ID to return a label for.
 *
 * @return string
 *   A human-readable name or FALSE if none can be found.
 */
function personalize_get_option_label_for_decision_and_choice($decision_name, $option_id) {
  if ($option_set = personalize_get_option_set_for_decision($decision_name)) {
    foreach ($option_set->options as $option) {
      if ($option['option_id'] == $option_id) {
        if (isset($option['option_label'])) {
          return check_plain($option['option_label']);
        }
        return FALSE;
      }
    }
  }
  return FALSE;
}

/**
 * Returns the option set for a decision name.
 *
 * @param $decision_name
 *   The name of the decision the option belongs to.
 *
 * @return
 *   The option set object or NULL if none can be found.
 */
function personalize_get_option_set_for_decision($decision_name) {
  $option_sets = personalize_option_set_load_multiple(array(), array('decision_name' => $decision_name));
  if (!empty($option_sets)) {
    return reset($option_sets);
  }
  elseif ($osid = personalize_resolve_stringified_osid($decision_name)) {
    return personalize_option_set_load($osid);
  }
  return NULL;
}

/**
 * Resolves an Option Set ID in the form 'osid-123' to just the numeric ID.
 *
 * @param string $osid
 *   An Option Set ID in the form 'osid-n' where n is the numeric ID.
 *
 * @return int
 *   The numeric part of the ID or NULL if there is none.
 */
function personalize_resolve_stringified_osid($osid) {
  if (is_numeric($osid)) {
    return (int) $osid;
  }
  $prefix = preg_quote(PERSONALIZE_OPTION_SET_PREFIX);
  if (preg_match("/^$prefix(\d+)$/", $osid, $matches) !== FALSE) {
    return $matches[1];
  }
  return NULL;
}

/**
 * Sets the active campaign context used in the admin UI.
 *
 * @param $campaign
 *   The campaign to set as the active campaign.
 */
function personalize_set_campaign_context($campaign) {
  $_SESSION['personalize_campaign'] = $campaign;
}

/**
 * Returns the current active campaign context for the admin UI.
 */
function personalize_get_campaign_context() {
  return isset($_SESSION['personalize_campaign']) ? $_SESSION['personalize_campaign'] : FALSE;
}

/**
 * Returns a map of status codes to human-readable statuses.
 *
 * @return array
 *   An array with status codes as keys and human-readable status names as
 *   values.
 */
function personalize_get_agent_status_map() {
  return array(
    PERSONALIZE_STATUS_NOT_STARTED => t('Not started'),
    PERSONALIZE_STATUS_RUNNING => t('Running'),
    PERSONALIZE_STATUS_PAUSED => t('Paused'),
    PERSONALIZE_STATUS_COMPLETED => t('Completed'),
  );
}

/**
 * Adds a "personalize this" link to the passed in contextual links array.
 *
 * @param $links
 *   An array corresponding to the #links property of the contextual links
 *   element.
 * @param $path
 *   The path that the "personalize this" link should link to.
 * @param $options
 *   An array of further options to set on the link.
 *
 * @see personalize_fields_contextual_links_view_alter().
 */
function personalize_add_personalize_this_contextual_link(&$links, $path, $options) {
  // Define a "personalize this" link.
  $link = array(
    'title' => t('Personalize this'),
    'href' => $path,
    'query' => array('destination' => $_GET['q']),
    'attributes' => array(
      'class' => array('personalize-this-contextual-link'),
    )
  );
  $link = array_merge_recursive($link, $options);
  $link += $options;

  $links['personalize'] = $link;
}

/**
 * Returns a themed dropbutton of links to create new personalized things.
 *
 * @return string
 */
function personalize_get_create_new_links_dropbutton($destination) {
  $links = module_invoke_all('personalize_create_new_links');
  $operations = array();
  foreach ($links as $info) {
    $operations[] = array(
      'title' => $info['title'],
      'href' => $info['path'],
      'query' => array('destination' => $destination),
    );
  }
 // $ops = theme('ctools_dropdown', array('title' => t('Click to Drop Down'), 'links' => $links));
  $ops = theme('ctools_dropdown', array(
    'title' => t('Add new'),
    'links' => $operations,
    'class' => 'personalize-ctools-dropdown'
  ));
  return $ops;
}

/**
 * =======================================================================
 *  C O N T R I B   M O D U L E   H O O K S
 * =======================================================================
 */

/**
 * Implements hook_visitor_actions_page_build().
 */
function personalize_visitor_actions_page_build(&$page, $actions) {
  // If we have campaigns with client-side triggered goals, we need to add
  // this information to Drupal.settings so that our client-side goal
  // listener can process them.
  $action_listeners = $agent_map = $client_side_goals = array();
  if (!empty($actions)) {
    foreach ($actions as $action) {
      $client_side_goals += personalize_goal_load_by_action($action);
    }
    foreach ($client_side_goals as $goal) {
      if ($agent = personalize_agent_load_agent($goal->agent)) {
        // Don't include goal information for campaigns that aren't running.
        if ($agent->getStatus() != PERSONALIZE_STATUS_RUNNING) {
          continue;
        }
        if (!isset($action_listeners[$goal->action])) {
          $action_listeners[$goal->action] = array();
        }

        $action_listeners[$goal->action][] = array(
          'agent' => $goal->agent,
          'value' => $goal->value,
        );

        // Add the agent to the agent_map setting so that the JavaScript
        // knows what function to call for sending the goal.
        $agent_map[$goal->agent] = array(
          'type' => $agent->getType(),
        );
        // We also need to ensure any assets required for that agent's client-side
        // functioning are loaded.
        $page['page_top'][$goal->agent] = array(
          '#attached' => $agent->getAssets()
        );
      }
    }
  }

  if (!empty($action_listeners)) {
    $page['page_top']['personalization_actions'] = array(
      '#attached' => array(
        'js' => array(
          array(
            'data' => array(
              'personalize' => array(
                'actionListeners' => $action_listeners,
                'agent_map' => $agent_map,
              ),
            ),
            'type' => 'setting'
          ),
        ),
      )
    );
  }
}

/**
 * =======================================================================
 *  P L U G I N   I N F O
 * =======================================================================
 */

/**
 * Implements hook_ctools_plugin_type().
 */
function personalize_ctools_plugin_type() {
  // Plugin to define new types of decision agents
  $plugins['agent_type'] = array(
    'cache' => TRUE,
    'use hooks' => TRUE,
    'classes' => array('handler'),
  );

  // Plugin to add contextual information to visitors
  $plugins['visitor_context'] = array(
    'cache' => TRUE,
    'use hooks' => TRUE,
    'classes' => array('handler')
  );

  // Plugin to define Option Set types.
  $plugins['option_set_type'] = array(
    'cache' => TRUE,
    'use hooks' => TRUE,
    'classes' => array('handler')
  );

  return $plugins;
}

/**
 * Fetch plugin.
 *
 * @param $agent_type
 *   Name of a specific agent_type to retrieve.
 *
 * @return
 *   An array with information about the requested agent type.
 */
function personalize_get_agent_type($agent_type) {
  ctools_include('plugins');
  return ctools_get_plugins('personalize', 'agent_type', $agent_type);
}

/**
 * Fetch metadata for all agent_type plugins.
 *
 * @return
 *   An array of arrays with information about all available agent types.
 */
function personalize_get_agent_types() {
  ctools_include('plugins');
  return ctools_get_plugins('personalize', 'agent_type');
}

/**
 * Load a particular agent from the database or from code.
 */
function personalize_agent_load($name, $reset = FALSE) {
  $agents = personalize_agent_load_multiple(array($name), array(), $reset);
  return isset($agents[$name]) ? $agents[$name] : NULL;
}

/**
 * Load all or specified agents from the database or from code.
 *
 * @param array $names
 *   An array of agent machine names to load
 * @param array $conditions
 *   An array of conditions to match where array keys match the object property
 *   and value is the value to match.
 * @param boolean $reset
 *   True to reset the object cache, false to load from cache where available.
 * @param boolean $include_completed
 *   True to include agents that have a status of completed, false to exclude.
 * @param string $sort
 *   The name of an object property to sort the results on.  Sorts will be
 *   ascending.  Alternatively, a sort comparison function to use.
 * @return array
 *   An array of agents matching the selection criteria keyed by machine name.
 */
function personalize_agent_load_multiple($names = array(), $conditions = array(), $reset = FALSE, $include_completed = TRUE, $sort = NULL) {
  ctools_include('export');
  if ($reset) {
    // @todo No way to just reset the cache for agents specified in the $names
    //   param?
    ctools_export_load_object_reset('personalize_agent');
  }
  // Status is stored outside of configuration.
  $limit_status = FALSE;
  if (isset($conditions['status'])) {
    $limit_status = $conditions['status'];
    unset($conditions['status']);
  }

  $defaults = array();
  if (empty($names) && empty($conditions)) {
    $defaults = ctools_export_load_object('personalize_agent', 'all');
  }
  elseif (!empty($names)) {
    $defaults = ctools_export_load_object('personalize_agent', 'names', $names);
  }
  elseif (!empty($conditions)) {
    $defaults = ctools_export_load_object('personalize_agent', 'conditions', $conditions);
  }

  if (!empty($sort)) {
    _personalize_loaded_object_sort($defaults, $sort);
  }
  if ($include_completed && !$limit_status) {
    return $defaults;
  }
  $limited = array();
  foreach ($defaults as $name => $agent) {
    // If a specific status is requested then return only that status, otherwise
    // limit the status to those that are not completed.
    $current_status = personalize_agent_get_status($agent->machine_name);
    // Skip agents not matching the requested status.
    if ($limit_status && $current_status != $limit_status) {
      continue;
    }
    // Skip completed agents if they should not be included.
    else if ($current_status & PERSONALIZE_STATUS_COMPLETED && !$include_completed) {
      continue;
    }
    $limited[$name] = $agent;
  }
  return $limited;
}

/**
 * Load all agents of a particular type.
 */
function personalize_agent_load_by_type($type, $reset = FALSE, $include_completed = TRUE) {
  return personalize_agent_load_multiple(array(), array('plugin' => $type), $reset, $include_completed);
}

/**
 * Fetch plugin.
 *
 * @param $name
 *   Name of a specific visitor_context plugin to retrieve.
 *
 * @return
 *   An array with information about the requested visitor context plugin.
 */
function personalize_get_visitor_context($name) {
  ctools_include('plugins');
  return ctools_get_plugins('personalize', 'visitor_context', $name);
}

/**
 * Fetch metadata for all visitor_context plugins.
 *
 * @return
 *   An array of arrays with information about all available visitor_context plugins.
 */
function personalize_get_visitor_contexts() {
  ctools_include('plugins');
  return ctools_get_plugins('personalize', 'visitor_context');
}
/**
 * Fetch plugin.
 *
 * @param $option_set_type
 *   Name of a specific Option Set type to retrieve.
 *
 * @return
 *   An array with information about the requested Option Set type.
 */
function personalize_get_option_set_type($option_set_type) {
  ctools_include('plugins');
  return ctools_get_plugins('personalize', 'option_set_type', $option_set_type);
}

/**
 * Fetch metadata for all option_set_type plugins.
 *
 * @return
 *   An array of arrays with information about all available Option Set types.
 */
function personalize_get_option_set_types() {
  ctools_include('plugins');
  return ctools_get_plugins('personalize', 'option_set_type');
}

/**
 * =======================================================================
 *  A G E N T  R E L A T E D  F U N C T I O N S
 * =======================================================================
 */

/**
 * Returns an instantiated agent.
 *
 * @param $agent_name
 * @return PersonalizeAgentInterface | NULL
 */
function personalize_agent_load_agent($agent_name, $reset = FALSE) {
  $loaded = &drupal_static(__FUNCTION__, array());
  if ($reset || !isset($loaded[$agent_name])) {
    $loaded[$agent_name] = FALSE;
    if ($agent_data = personalize_agent_load($agent_name, $reset)) {
      ctools_include('plugins');
      if ($agent_class = ctools_plugin_load_class('personalize', 'agent_type', $agent_data->plugin, 'handler')) {
        if ($agent = call_user_func_array(array($agent_class, 'create'), array($agent_data))) {
          $loaded[$agent_name] = $agent;
        }
      }
    }
  }
  return $loaded[$agent_name] ? $loaded[$agent_name] : NULL;
}

/**
 * Returns whether a machine name is already taken by an existing agent.
 *
 * @param $machine_name
 *   The machine name to check.
 * @return boolean
 */
function personalize_agent_machine_name_exists($machine_name) {
  $agent_exists = db_query_range('SELECT 1 FROM {personalize_agent} WHERE machine_name = :name', 0, 1, array(':name' => $machine_name))->fetchField();
  return $agent_exists;
}

/**
 * Generates a machine-readable name based on the passed in name.
 *
 * @param $name
 *   The human-readable name of the agent.
 * @param $exists_callback
 *   (Optional) the callback function to see if the name is already in use.
 * @param $replace_character
 *   (Optional) the replace character to use, defaults to '-'.
 * @return string
 *   The machine-readable name.
 */
function personalize_generate_machine_name($name, $exists_callback = NULL, $replace_character = '-') {
  // Machine names must contain only lower case letters.
  $machine_name = drupal_strtolower($name);
  // Remove any disallowed characters.
  $machine_name = preg_replace('/' . PERSONALIZE_MACHINE_NAME_REPLACE_PATTERN . '/', $replace_character, $machine_name);
  // Get rid of instances of multiple replace characters after replacement.
  $re = '\\' . $replace_character . '{2,}';
  $machine_name = preg_replace('/' . $re . '/', $replace_character, $machine_name);
  // Keep the name within the allowed length.
  $machine_name = substr($machine_name, 0, PERSONALIZE_MACHINE_NAME_MAXLENGTH);

  if (!is_callable($exists_callback)) {
    // We don't need to concern ourselves with the uniqueness aspect, just return what
    // we've generated.
    return $machine_name;
  }
  $i = 1;
  while ($exists_callback($machine_name)) {
    if (isset($suffix)) {
      // If we already have a suffix, replace it.
      $suffix_length = strlen($suffix);
      $machine_name = substr($machine_name, 0, -$suffix_length);
    }
    else {
      // Strip 4 characters off the end to allow for generating a suffix.
      $machine_name = substr($machine_name, 0, PERSONALIZE_MACHINE_NAME_MAXLENGTH - 4);
    }

    $suffix = ($replace_character . ++$i);
    $machine_name .= $suffix;
  }
  return $machine_name;
}

/**
 * Saves an agent to the database.
 */
function personalize_agent_save($agent) {
  $prior_values = personalize_agent_load($agent->machine_name);
  if ($prior_values) {
    // Make sure we don't clobber any values that may have been saved during
    // a prior call to personalize_agent_save.
    $prior_agent_array = (array) $prior_values;
    $agent_array = (array) $agent;
    $agent_array += $prior_agent_array;
    $agent_array['data'] += $prior_agent_array['data'];
    $agent = (object) $agent_array;
  }
  module_invoke_all('personalize_agent_presave', $agent);
  // Default to caching decisions if not specified.
  if (!isset($agent->data['cache_decisions'])) {
    $agent->data['cache_decisions'] = 1;
  }
  db_merge('personalize_agent')
    ->key(array('machine_name' => $agent->machine_name))
    ->fields(array(
      'plugin' => $agent->plugin,
      'label' => $agent->label,
      'data' => serialize($agent->data),
      'started' => isset($agent->started) ? $agent->started : 0,
    ))
    ->execute();

  // Make sure the static cache for this agent is reset.
  personalize_agent_load($agent->machine_name, TRUE);

  // Also reset the visitor context cache.
  personalize_visitor_context_expiration_clear();

  // And reset the verification status of the agent.
  _personalize_agent_verification_cache_clear($agent->machine_name);

  // Call the save callback of the agent type.
  ctools_include('plugins');
  if ($class = ctools_plugin_load_class('personalize', 'agent_type', $agent->plugin, 'handler')) {
    if ($agent_instance = call_user_func_array(array($class, 'create'), array($agent))) {
      $agent_instance->postSave($prior_values);
    }
    else {
      drupal_set_message(t('Could not instantiate your agent, please check your configuration'), 'error');
    }
  }

  module_invoke_all('personalize_agent_save', $agent);
  return $agent;
}

/**
 * Deletes an agent.
 */
function personalize_agent_delete($agent_name) {
  $agent = personalize_agent_load($agent_name);
  db_query('DELETE FROM {personalize_agent} WHERE machine_name = :machine_name', array(':machine_name' => $agent_name));
  db_query('DELETE FROM {personalize_campaign_goals} WHERE agent = :agent', array(':agent' => $agent_name));
  variable_del(_personalize_agent_get_status_variable($agent_name));
  _personalize_agent_verification_cache_clear($agent_name);
  module_invoke_all('personalize_agent_delete', $agent);
}

/**
 * Returns the export output for an agent.
 */
function personalize_agent_export($agent, $indent = '') {
  $output = ctools_export_object('personalize_agent', $agent, $indent);
  return $output;
}

/**
 * =======================================================================
 *  O P T I O N  S E T  R E L A T E D  F U N C T I O N S
 * =======================================================================
 */


/**
 * Saves an Option Set to the database
 */
function personalize_option_set_save($option_set) {
  if (!isset($option_set->plugin) || !isset($option_set->agent) || !isset($option_set->options) || !is_array($option_set->options)) {
    throw new Exception('An Option Set must have a type, an agent and an array of options');
  }
  if (isset($option_set->osid)) {
    $prior_values = personalize_option_set_load($option_set->osid, TRUE);
    if ($prior_values) {
      // Make sure we don't clobber any values that may have been saved during
      // a prior call to personalize_option_set_save.
      $prior_os_array = (array) $prior_values;
      $os_array = (array) $option_set;
      $os_array += $prior_os_array;
      $os_array['data'] += $prior_os_array['data'];
      // Pull out the existing options into an array keyed by option id
      // so that we can easily grab information from them.
      $old_options = array();
      foreach ($prior_os_array['options'] as $old_option) {
        $old_options[$old_option['option_id']] = $old_option;
      }
      // This ensures things like fixed targeting information don't get clobbered
      // when we're saving just basic information about the options.
      // @todo There really has to be a better way, but it may involve restructuring
      //   Option Set data :(
      foreach ($os_array['options'] as &$option) {
        if (isset($option['option_id']) && isset($old_options[$option['option_id']])) {
          $option += $old_options[$option['option_id']];
        }
      }
      $option_set = (object) $os_array;
    }
  }

  if (!isset($option_set->data)) {
    $option_set->data = array();
  }

  $option_set->options = personalize_ensure_unique_option_ids($option_set->options);

  // Allow modules to alter an option set before it is saved.
  module_invoke_all('personalize_option_set_presave', $option_set);

  $option_set->mvt = isset($option_set->mvt) ? $option_set->mvt : NULL;
  $option_set->decision_name = isset($option_set->decision_name) ? $option_set->decision_name : '';

  $fields = array(
    'plugin' => $option_set->plugin,
    'agent' => $option_set->agent,
    'label' => isset($option_set->label) ? $option_set->label : 'Untitled Option Set',
    'mvt' => $option_set->mvt,
    'decision_name' => $option_set->decision_name,
    'stateful' => isset($option_set->stateful) ? $option_set->stateful : 0,
    'executor' => isset($option_set->executor) ? $option_set->executor : 'show',
    'options' => serialize($option_set->options),
    'winner' => isset($option_set->winner) ? $option_set->winner : NULL,
    'data' => serialize($option_set->data),
    'preview_link' => isset($option_set->preview_link) ? $option_set->preview_link : NULL,
  );

  if (isset($option_set->osid)) {
    db_update('personalize_option_sets')
      ->condition('osid', $option_set->osid)
      ->fields($fields)
      ->execute();
    module_invoke_all('entity_update', $option_set, 'personalize_option_set');
  }
  else {
    // We don't use db_merge because it doesn't return the new ID if it's
    // a new record.
    $osid = db_insert('personalize_option_sets')
      ->fields($fields)
      ->execute();
    $option_set->osid = $osid;
    module_invoke_all('entity_insert', $option_set, 'personalize_option_set');
  }
  // Make sure both decision_point and decision_name are set.
  $option_set->decision_name = personalize_get_decision_name_for_option_set($option_set);
  $option_set->decision_point = personalize_get_decision_point_name_for_option_set($option_set);

  // Make sure the static cache is reset for this option set.
  personalize_option_set_load($option_set->osid, TRUE);

  // Pause the campaign because changes have been made.
  personalize_pause_if_running($option_set->agent);
  // Set the active campaign to the one this option set was created for.
  personalize_set_campaign_context($option_set->agent);

  // Reset the verification cache for this agent.
  _personalize_agent_verification_cache_clear($option_set->agent);


  // Allow modules to act after an option set has been saved.
  module_invoke_all('personalize_option_set_save', $option_set);
  return $option_set;
}

/**
 * Load a single Option Set based on Option Set ID
 */
function personalize_option_set_load($osid = NULL, $reset = FALSE){
  $osids = (isset ($osid) ? array($osid) : array());
  $option_sets = personalize_option_set_load_multiple($osids, array(), $reset);
  return $option_sets ? reset ($option_sets) : FALSE;
}

/**
 * Loads all option sets, or a set as constrained by the ids or conditions passed in.
 *
 * @param array $osids
 *   An array of Option Set IDs to load.
 * @param array $conditions
 *   An array of conditions to constrain the query to.
 * @param bool $reset
 *   Whether to reset the cache and load fresh from the DB.
 * @return array
 *   An array of Option Set objects.
 */
function personalize_option_set_load_multiple($osids = array(), $conditions = array(), $reset = FALSE){
  return entity_load('personalize_option_set', $osids, $conditions, $reset);
}

/**
 * Implements hook_personalize_option_set_load().
 */
function personalize_personalize_option_set_load($option_sets) {
  foreach ($option_sets as $option_set) {
    $option_set->options = unserialize($option_set->options);
    $option_set->data = unserialize($option_set->data);
    $option_set->decision_name = personalize_get_decision_name_for_option_set($option_set);
    $option_set->decision_point = personalize_get_decision_point_name_for_option_set($option_set);
  }
}

/**
 * Returns all Option Sets of a given type.
 */
function personalize_option_set_load_by_type($type, $sort = NULL) {
  $option_sets = &drupal_static(__FUNCTION__, array());

  if (!isset($option_sets[$type])) {
    $option_sets[$type] = personalize_option_set_load_multiple(array(), array('plugin' => $type), FALSE, $sort);
  }

  return $option_sets[$type];
}

/**
 * Returns all Option Sets for a given agent.
 */
function personalize_option_set_load_by_agent($agent_name, $reset = FALSE) {
  $option_sets = &drupal_static(__FUNCTION__, array());

  if ($reset || !isset($option_sets[$agent_name])) {
    $option_sets[$agent_name] = personalize_option_set_load_multiple(array(), array('agent' => $agent_name), $reset);
  }

  return $option_sets[$agent_name];
}

/**
 * Returns the passed in DB record with serialized fields unserialized.
 *
 * @param $record
 * @return mixed
 */
function _personalize_unpack_option_set($record) {
  $option_set = $record;
  $option_set->options = unserialize($record->options);
  $option_set->data = unserialize($record->data);
  $option_set->decision_name = personalize_get_decision_name_for_option_set($record);
  $option_set->decision_point = personalize_get_decision_point_name_for_option_set($record);
  return $option_set;
}

/**
 * Returns a particular option set selection for display in JSON.
 *
 * @param $option_set
 *   The set of options.
 * @param $choice_name
 *   The choice to be displayed from the options.
 */
function personalize_option_set_ajax($decision_name, $choice_name) {
  $option_set = personalize_get_option_set_for_decision($decision_name);
  foreach($option_set->options as $delta => $option) {
    if ($option['option_id'] == $choice_name) {
      $selected = $option;
      break;
    }
  }
  if (!isset($selected)) {
    return array();
  }

  $plugin = personalize_get_option_set_type($option_set->plugin);
  $render = module_invoke($plugin['module'], 'personalize_option_load', $option_set, $option);
  $cleaned_decision_name = check_plain($decision_name);
  $commands = array();
  $commands[] = ajax_command_replace('#personalize-' . $cleaned_decision_name, '<div id="personalize-' . $cleaned_decision_name . '">' . drupal_render($render) . '</div>');
  $page = array('#type' => 'ajax', '#commands' => $commands);
  ajax_deliver($page);
}

/**
 * Deletes the specified option set.
 *
 * @param $osid
 *   The ID of the option set to delete.
 */
function personalize_option_set_delete($osid) {
  if ($option_set = personalize_option_set_load($osid)) {
    db_delete('personalize_option_sets')
      ->condition('osid', $osid)
      ->execute();
    // Pause the campaign because changes have been made.
    personalize_pause_if_running($option_set->agent);

    // Clear the option set cache.
    personalize_option_set_load(NULL, TRUE);

    module_invoke_all('personalize_option_set_delete', $option_set);
  }
}

/**
 * Returns the decision point name to use for an option set.
 *
 * @param $option_set
 * @return string
 *
 * @todo This is duplicating logic we have on the js side, maybe we can
 *   add this to the settings so the js side doesn't need to figure out
 *   the point name?
 */
function personalize_get_decision_point_name_for_option_set($option_set) {
  if (!empty($option_set->mvt)) {
    return $option_set->mvt;
  }
  return personalize_get_decision_name_for_option_set($option_set);
}

/**
 * Returns the decision name to use for an option set.
 *
 * @param $option_set
 * @return string
 */
function personalize_get_decision_name_for_option_set($option_set) {
  if (!empty($option_set->decision_name)) {
    return $option_set->decision_name;
  }
  // Default to a name based on the osid.
  return personalize_stringify_osid($option_set->osid);
}

/**
 * Returns a list of all available executors.
 */
function personalize_get_executors() {
  $executors = array(
    'show' => array(
      'title' => t('Pre-load all variations'),
      'description' => t('Typically faster for fewer variations.'),
      'details' => t('Preloading renders all of the variations on the page but shows only the personalized variation using Javascript.  This allows the page to be cached and the variation to load instantly.'),
    ),
    'callback' => array(
      'title' => 'Load personalized variation only',
      'description' => t('Faster page-load for many or complex variations.'),
      'details' => t('No variations are loaded with the page.  After the page loads, the personalized variation loads via an AJAX call (there may be a slight delay).  Use this option for uncached pages, eg. where authentication is required.'),
    ),
  );
  drupal_alter('personalize_executors', $executors);
  return $executors;
}

/**
 * =======================================================================
 * M V T  R E L A T E D
 * =======================================================================
 */

/**
 * Saves a multivariate test to the db.
 *
 * @param $mvt
 *   An object representing a multivariate test. Must have the following
 *   properties:
 *   - name A machine-readable name
 *   - agent The name of the agent this MVT is for.
 *   Optional additional properties:
 *   - option_sets An associative array of option sets keyed by osid. The values
 *     can be NULL.
 *   - label A human readable name for this MVT
 *   - stateful Whether this MVT should behave as stateful, allowing users
 *     to share the experience via the URL.
 */
function personalize_mvt_save($mvt) {
  if (!isset($mvt->label) || !isset($mvt->agent)) {
    throw new Exception('A multivariate test must have a name and an agent associated with it');
  }

  if (!isset($mvt->machine_name)) {
    $mvt->machine_name = personalize_generate_machine_name($mvt->label, 'personalize_mvt_machine_name_exists');
  }

  // Save the MVT.
  $fields = array(
    'machine_name' => $mvt->machine_name,
    'label' => $mvt->label,
    'agent' => $mvt->agent,
    'stateful' => isset($mvt->stateful) ? $mvt->stateful : 0
  );
  db_merge('personalize_multivariate_test')
    ->key(array('machine_name' => $mvt->machine_name))
    ->fields($fields)
    ->execute();
  // Find all option sets that were previously set to this MVT. Passing TRUE
  // as the 3rd param ensures they are loaded fresh from the DB.
  $options_sets = personalize_option_set_load_multiple(array(), array('mvt' => $mvt->machine_name), TRUE);

  // See if there are option sets we need to remove.
  foreach ($options_sets as $osid => $os) {
    if (!isset($mvt->option_sets[$osid])) {
      $os->mvt = NULL;
      personalize_option_set_save($os);
    }
  }
  // Now update the option sets to mark them as belonging to this MVT.
  foreach ($mvt->option_sets as $osid => $os) {
    if (!isset($options_sets[$osid])) {
      // Load the option set fresh from the DB.
      $option_set = personalize_option_set_load($osid, TRUE);
      $option_set->mvt = $mvt->machine_name;
      personalize_option_set_save($option_set);
    }
  }
}

/**
 * Returns whether there's already an MVT with the passed in name.
 *
 * @param $name
 *   The machine name to check.
 * @return bool
 *   TRUE if the name already exists, FALSE otherwise.
 *
 */
function personalize_mvt_machine_name_exists($name) {
  $exists = db_query_range('SELECT 1 FROM {personalize_multivariate_test} WHERE machine_name = :name', 0, 1, array(':name' => $name))->fetchField();
  return $exists;
}

/**
 * Deletes an MVT.
 */
function personalize_mvt_delete($name) {
  $mvt = personalize_mvt_load($name);
  $result = db_delete('personalize_multivariate_test')
    ->condition('machine_name', $name)
    ->execute();
  if ($result) {
    foreach ($mvt->option_sets as $osid => $option_set) {
      $option_set->mvt = NULL;
      personalize_option_set_save($option_set);
    }
    module_invoke_all('personalize_mvt_delete', $mvt);
    return TRUE;
  }

  return FALSE;
}

/**
 * Loads an MVT from the database.
 *
 * @param $name
 * @return mixed
 */
function personalize_mvt_load($name) {
  $loaded = &drupal_static(__FUNCTION__, array());
  if (!isset($loaded[$name])) {
    $result = db_select('personalize_multivariate_test', 'm')
      ->fields('m')
      ->condition('m.machine_name', $name)
      ->execute();
    if ($record = $result->fetchObject()) {
      // Get the Option Sets for this test.
      $option_sets = personalize_option_set_load_multiple(array(), array('mvt' => $name));
      $record->option_sets = $option_sets;
      $loaded[$name] = $record;
    }
    else {
      $loaded[$name] = FALSE;
    }
  }
  return $loaded[$name];
}

/**
 * Loads all MVTs from the database.
 *
 * @return mixed
 */
function personalize_mvt_load_all() {
  $loaded = &drupal_static(__FUNCTION__, array());
  if (empty($loaded)) {
    $result = db_select('personalize_multivariate_test', 'm')
      ->fields('m')
      ->execute();
    foreach ($result as $record) {
      // Get the Option Sets for this test.
      $option_sets = personalize_option_set_load_multiple(array(), array('mvt' => $record->machine_name));
      $record->option_sets = $option_sets;
      $loaded[$record->machine_name] = $record;
    }
  }
  return $loaded;
}

/**
 * Loads all MVTs for the specified agent.
 *
 * @param $agent_name
 *   THe name of the agent.
 * @return array
 *   An array of MVT objects.
 *
 */
function personalize_mvt_load_all_by_agent($agent_name) {
  $loaded = &drupal_static(__FUNCTION__, array());
  if (empty($loaded)) {
    $result = db_select('personalize_multivariate_test', 'm')
      ->fields('m')
      ->condition('agent', $agent_name)
      ->execute();
    foreach ($result as $record) {
      // Get the Option Sets for this test.
      $option_sets = personalize_option_set_load_multiple(array(), array('mvt' => $record->machine_name));
      $record->option_sets = $option_sets;
      $loaded[$record->machine_name] = $record;
    }
  }
  return $loaded;
}

/**
 * =======================================================================
 *  V I S I T O R  C O N T E X T  R E L A T E D
 * =======================================================================
 */

/**
 * Implements hook_personalize_visitor_contexts().
 */
function personalize_personalize_visitor_context() {
  $info = array();
  $path = drupal_get_path('module', 'personalize') . '/plugins';
  $info['user_profile_context'] = array(
    'path' => $path . '/visitor_context',
    'handler' => array(
      'file' => 'UserProfileContext.inc',
      'class' => 'UserProfileContext',
    ),
  );
  return $info;
}

/**
 * Load the visitor context cache expiration settings.
 *
 * These cache expiration settings are cached as they would only change when
 * either 1) the campaign status changes; or 2) the disallowed contexts change.
 *
 * @return array
 *   An array of visitor context cache expiration settings with keys for each
 *   option within a context.  Suitable for use with JavaScript.
 *
 * @see personalize.js
 */
function personalize_visitor_context_expiration_load() {
  // Load from the cache if available.
  if ($expiration = cache_get(PERSONALIZE_CONTEXT_EXPIRATION_CACHE)) {
    return $expiration->data;
  }
  $expiration = array();
  // Get all currently running campaigns
  $current_campaigns = personalize_agent_load_multiple(array(), array('status' => PERSONALIZE_STATUS_RUNNING));
  $current_campaign_contexts = array();
  // Get the visitor context for each of the currently running campaigns.
  foreach ($current_campaigns as $campaign) {
    // Add auto-targeting contexts.
    if (!empty($campaign->data['visitor_context'])) {
      foreach ($campaign->data['visitor_context'] as $plugin => $contexts) {
        if (!isset($current_campaign_contexts[$plugin])) {
          $current_campaign_contexts[$plugin] = array();
        }
        $current_campaign_contexts[$plugin] = array_merge($current_campaign_contexts[$plugin], $contexts);
      }
    }
    // Add explicit targeting contexts for options within the campaign.
    $option_sets = personalize_option_set_load_by_agent($campaign->machine_name);
    foreach($option_sets as $option_set) {
      foreach($option_set->options as $option) {
        if (!empty($option['fixed_targeting_rules'])) {
          foreach($option['fixed_targeting_rules'] as $rule) {
            $current_campaign_contexts[$rule['plugin']][$rule['context']] = $rule['context'];
          }
        }
      }
    }
  }
  // Now loop over those contexts and add the option cache expiration data.
  $disallowed = variable_get('personalize_visitor_context_disabled', array());
  foreach ($current_campaign_contexts as $plugin_name => $selected_contexts) {
    if ($class = ctools_plugin_load_class('personalize', 'visitor_context', $plugin_name, 'handler')) {
      $context_options = call_user_func(array($class, 'getOptions'));
      foreach ($selected_contexts as $code) {
        if (isset($disallowed[$plugin_name][$code])) {
          continue;
        }
        if (!empty($context_options[$code]['cache_type'])) {
          $expiration['visitor_context:' . $plugin_name . ':' . $code] = $context_options[$code]['cache_type'] == 'session' ? 'session' : $context_options[$code]['cache_expiration'];
        }
      }
    }
  }
  // Set in the cache for easier future retrieval.
  cache_set(PERSONALIZE_CONTEXT_EXPIRATION_CACHE, $expiration);
  return $expiration;
}

/**
 * Clear the visitor context expiration cache settings.
 */
function personalize_visitor_context_expiration_clear() {
  cache_clear_all(PERSONALIZE_CONTEXT_EXPIRATION_CACHE, 'cache');
}

/**
 * Helper function to read the current agent's verification status from cache.
 *
 * @param string $agent_name
 *   The machine name of the agent to get verification for.
 * @result bool
 *   True if agent is verified, false if not.
 */
function _personalize_agent_verification_cache_get($agent_name) {
  $verification = &drupal_static(__FUNCTION__);
  if (!isset($verification)) {
    $cache = cache_get(PERSONALIZE_AGENT_VERIFY_CACHE);
    if ($cache) {
      $verification = $cache->data;
    }
    else {
      $verification = array();
    }
  }
  if (!isset($verification[$agent_name])) {
    $verification[$agent_name] = personalize_verify_agent($agent_name, FALSE);
    cache_set(PERSONALIZE_AGENT_VERIFY_CACHE, $verification);
  }
  return $verification[$agent_name];
}

/**
 * Helper function to clear the cache of the verification status for a
 * particular agent.
 *
 * @param string $agent_name
 *   The machine name of the agent that should have cache cleared.  If not
 *   passed, entire cache will be cleared.
 */
function _personalize_agent_verification_cache_clear($agent_name = NULL) {
  $cache = cache_get(PERSONALIZE_AGENT_VERIFY_CACHE);
  if (!$cache) {
    return;
  }
  $verification = $cache->data;
  if (empty($agent_name)) {
    $verification = array();
  }
  else if (isset($verification[$agent_name])) {
    unset($verification[$agent_name]);
  }
  cache_set(PERSONALIZE_AGENT_VERIFY_CACHE, $verification);
}

/**
 * =======================================================================
 *  G O A L  R E L A T E D
 * =======================================================================
 */


/**
 * Sets a goal to be sent to an agent during goal processing.
 *
 * @param $agent_name
 *   The name of the agent to send the goal to.
 * @param $goal_name
 *   The name of the goal to send.
 * @param $value
 *   The value of the goal to send.
 * @see personalize_process_goals().
 */
function personalize_set_goal($agent_name, $goal_name, $value) {
  if (!isset($_SESSION['personalize_goals'][$agent_name])) {
    $_SESSION['personalize_goals'][$agent_name] = array();
  }
  $_SESSION['personalize_goals'][$agent_name][$goal_name][] = $value;
}

/**
 * Retrieves all unprocessed goals that have been set on agents.
 *
 * @return an array of goals or NULL.
 */
function personalize_get_goals() {
  return (isset($_SESSION['personalize_goals']) ? $_SESSION['personalize_goals'] : NULL);
}

/**
 * Clears the list of goals so they don't get processed again.
 */
function personalize_clear_goals() {
  unset($_SESSION['personalize_goals']);
}

/**
 * Processes all goals by sending them to the agents they've been set on.
 */
function personalize_process_goals(&$page) {
  if ($goals = personalize_get_goals()) {
    $agent_map = $goals_attained = array();
    foreach ($goals as $agent_name => $agent_goals) {
      $agent = personalize_agent_load_agent($agent_name);
      if (!$agent || !($agent instanceof PersonalizeAgentGoalInterface)) {
        continue;
      }
      if (!$agent->useClientSideGoalDelivery()) {
        foreach ($agent_goals as $goal_name => $values) {
          foreach ($values as $value) {
            $agent->sendGoal($goal_name, $value);
          }
        }
      }
      else {
        // Ensure any assets for this agent are loaded to the page.
        $page['page_top'][$agent_name] = array(
          '#attached' => $agent->getAssets()
        );
        // Add this agent to the agent map.
        $agent_map[$agent_name] = array(
          'type' => $agent->getType()
        );
        $goals_attained[$agent_name] = array();
        foreach ($agent_goals as $goal_name => $values) {
          foreach ($values as $value) {
            $goals_attained[$agent_name][] = array(
              'name' => $goal_name,
              'value' => $value,
            );
          }
        }
      }
    }
    $page['page_top']['personalization']['#attached']['js'][] = array(
      'type' => 'setting',
      'data' => array(
        'personalize' => array(
          'agent_map' => $agent_map,
          'goals_attained' => $goals_attained,
        ),
      ),
    );
    personalize_clear_goals();
  }
}


/**
 * Load a single goal by ID
 */
function personalize_goal_load($goal_id = NULL, $reset = FALSE){
  $ids = (isset ($goal_id) ? array($goal_id) : array());
  $goals = personalize_goal_load_multiple($ids, array(), $reset);
  return $goals ? reset ($goals) : FALSE;
}

/**
 * Loads all goals, or a set as constrained by the ids or conditions passed in.
 *
 * @param array $ids
 *   An array of Goal IDs to load.
 * @param array $conditions
 *   An array of conditions to constrain the query to.
 * @param bool $reset
 *   Whether to reset the cache and load fresh from the DB.
 * @return array
 *   An array of Goal objects.
 */
function personalize_goal_load_multiple($ids = FALSE, $conditions = array(), $reset = FALSE){
  return entity_load('personalize_campaign_goal', $ids, $conditions, $reset);
}


/**
 * Loads all goals satisfying the specified conditions.
 */
function personalize_goal_load_by_conditions($conditions = array()) {
  return personalize_goal_load_multiple(array(), $conditions);
}

/**
 * @param $action
 * @return mixed
 */
function personalize_goal_load_by_action($action) {
  $goals = &drupal_static(__FUNCTION__, array());

  if (!isset($goals[$action])) {
    $goals[$action] = personalize_goal_load_by_conditions(array('action' => $action));
  }

  return $goals[$action];
}

/**
 * Implements hook_visitor_action_subscribe().
 */
function personalize_visitor_action_subscribe($name) {
  // See if we have any goals set up for this action
  $campaign_goals = personalize_goal_load_by_action($name);
  $subscribers = array();
  if (!empty($campaign_goals)) {
    $subscribers[] = 'personalize_goal_action_subscriber';
  }
  return $subscribers;
}

/**
 * Implements hook_visitor_actions_delete_action().
 */
function personalize_visitor_actions_delete_action($action) {
  // Delete any goals we have on this action.
  $result = db_select('personalize_campaign_goals', 'g')
    ->fields('g', array('id'))
    ->condition('action', $action['machine_name'])
    ->execute();
  foreach ($result as $row) {
    // We pass in FALSE as the second parameter to tell it not
    // to rebuild subscribers as that will be done on the
    // visitor_actions side seeing as this deletion comes from
    // there.
    personalize_goal_delete($row->id, FALSE);
  }
}

/**
 * Deletes a goal from the db.
 *
 * @param $goal_id
 *   THe id of the goal to delete.
 * @param bool $rebuild_subscribers
 *   TRUE if the action subscribers cache needs to be rebuilt
 */
function personalize_goal_delete($goal_id, $rebuild_subscribers = TRUE) {
  if ($rebuild_subscribers) {
    $action_name = db_select('personalize_campaign_goals', 'g')
      ->fields('g', array('action'))
      ->condition('id', $goal_id)
      ->execute()
      ->fetchField();
  }
  // Delete the goal.
  db_delete('personalize_campaign_goals')
    ->condition('id', $goal_id)
    ->execute();
  if (isset($action_name)) {
    // We only need to clear the subscribers cache if we no longer have
    // a goal that uses this action.
    $result = db_select('personalize_campaign_goals', 'g')
      ->fields('g', array('action'))
      ->condition('action', $action_name)
      ->execute()
      ->fetchField();
    if (!$result) {
      visitor_actions_clear_subscribers($action_name);
    }
  }
}

/**
 * Ensures goals are sent for all campaigns that use the triggered action.
 *
 * @param $name
 *   The name of the user action that was just triggered.
 * @param $context
 *   An array of context about the action that was triggered.
 */
function personalize_goal_action_subscriber($name, $context) {
  $campaign_goals = personalize_goal_load_by_action($name);

  foreach ($campaign_goals as $goal) {
    if (empty($goal->value) && isset($context['value']) && !empty($context['value'])) {
      $goal->value = $context['value'];
    }
    personalize_set_goal($goal->agent, $goal->action, $goal->value);
  }
}

/**
 * Saves a goal for an agent.
 *
 * @param $agent_name
 *   The name of the agent this goal is for.
 * @param $action_name
 *   The name of the action.
 * @param $goal_value
 *   The reward value to send when the goal is triggered.
 */
function personalize_goal_save($agent_name, $action_name, $goal_value) {
  $agent = personalize_agent_load_agent($agent_name);
  if (!($agent instanceof PersonalizeAgentGoalInterface)) {
    throw new PersonalizeException(t('Goals are not supported by this campaign.'));
  }
  // If this is the first campaign that uses this action as a goal, the
  // action subscribers cache will need to be rebuilt.
  $exists = db_select('personalize_campaign_goals', 'g')
    ->fields('g', array('id'))
    ->condition('action', $action_name)
    ->execute()
    ->fetchField();
  db_merge('personalize_campaign_goals')
    ->key(array('agent' => $agent_name, 'action' => $action_name))
    ->fields(array('agent' => $agent_name, 'action' => $action_name, 'value' => $goal_value))
    ->execute();

  $goal_array = array(
    'agent' => $agent_name,
    'name' => $action_name,
    'value' => $goal_value
  );
  $goal_entity = (object) $goal_array;
  if (!$exists) {
    visitor_actions_clear_subscribers($action_name);
    module_invoke_all('entity_insert', $goal_entity, 'personalize_campaign_goal');
  }
  else {
    $goal_entity->id = $exists;
    module_invoke_all('entity_update', $goal_entity, 'personalize_campaign_goal');
  }

  // Clear the agent's verification status.
  _personalize_agent_verification_cache_clear($agent_name);
  module_invoke_all('personalize_goal_save', $goal_array);

}

/**
 * =======================================================================
 *  H E L P E R  F U N C T I O N S
 * =======================================================================
 */

/**
 * Returns a letter or number to use for an option with the given index.
 *
 * @param $index
 *
 * @return Either an uppercase character or a number, depending on whether
 *   the passed in index is < 26.
 */
function _personalize_generate_option_index($index) {
  $index = (int) $index;
  if ($index < 26) {
    // supply a character array to set up default option names.
    $letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    $option = $letters[$index];
  } else {
    // If we get past Z, just return the number of the option +1 so we start at 27
    $option = $index + 1;
  }
  return $option;
}

/**
 * Returns the passed in Option Set as an array for use in JS settings.
 *
 * @param $option_set
 *   An object representing an Option Set.
 * @return array
 *   An associative array with one element, with osid as key and
 *   an array representing the Option Set as value.
 */
function _personalize_convert_option_set_to_js_setting($option_set) {
  // We never want to use numeric keys in the JS so convert it to a
  // string using the prefix if it is numeric.
  $js_id = personalize_stringify_osid($option_set->osid);
  $os_array = (array) $option_set;
  $os_array['osid'] = $js_id;
  $os_array['label'] = check_plain($os_array['label']);
  $option_names = array();
  foreach ($option_set->options as $i => $option) {
    $option_names[] = $option['option_id'];
    if (isset($option_set->winner) && $option_set->winner == $option['option_id']) {
      $os_array['winner'] = $i;
    }
    $os_array['options'][$i]['option_label'] = check_plain($option['option_label']);
  }
  $os_array['option_names'] = $option_names;
  $os_array += array(
    'selector' => '[data-personalize=' . $js_id . ']'
  );

  return array(
    $js_id => $os_array
  );
}

/**
 * Helper function to add required #states to form elements.
 *
 * @param $element
 *   The form element to add the #states property to.
 */
function personalize_form_element_add_states($state, &$element) {
  // If this element has children but is not a fieldset, we add the #states
  // property to the children, not the element itself.
  $children = element_children($element);
  $is_fieldset = isset($element['#type']) && $element['#type'] === 'fieldset';
  if (!$is_fieldset && !empty($children)) {
    foreach ($children as $child) {
      personalize_form_element_add_states($state, $element[$child]);
    }
  }
  else {
    // Add the specified state to the element.
    $element['#states'] = isset($element['#states']) ? $element['#states'] : array();
    $element['#states']['visible'] = isset($element['#states']['visible']) ? $element['#states']['visible'] : array();
    $element['#states']['visible'] += $state;
    if (isset($element['#required']) && $element['#required']) {
      $element['#states']['required'] = $state;
      unset($element['#required']);
    }
  }
}

/**
 * Returns a non-numeric osid.
 *
 * @param $osid
 * @return string
 */
function personalize_stringify_osid($osid) {
  return is_numeric($osid) ? PERSONALIZE_OPTION_SET_PREFIX . $osid : $osid;
}
